<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:datetime="http://exslt.org/dates-and-times"
	xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:numishare="https://github.com/ewg118/numishare" exclude-result-prefixes="xs" version="2.0" xmlns:exsl="http://exslt.org/common"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" extension-element-prefixes="exsl">
	<xsl:output method="xml" indent="yes" encoding="UTF-8"/>

	<!-- change eXist URL if running on a server other than localhost -->
	<xsl:variable name="exist-config" select="/content/exist-config"/>
	<!-- load config.xml from eXist into a variable which is later processed with exsl:node-set -->
	<xsl:variable name="config" select="document(concat($exist-config, 'numishare/config.xml'))"/>

	<!-- template variables -->
	<!-- adminDesc variables -->
	<xsl:variable name="collection">
		<xsl:choose>
			<xsl:when test="count(//elem[@mapping='collection']) &gt; 0">
				<xsl:value-of select="//elem[@mapping='collection'][1]"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="exsl:node-set($config)/config/template/collection"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	<xsl:variable name="owner">
		<xsl:choose>
			<xsl:when test="count(//elem[@mapping='owner']) &gt; 0">
				<xsl:value-of select="//elem[@mapping='owner'][1]"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="exsl:node-set($config)/config/template/owner"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	<xsl:variable name="repository">
		<xsl:choose>
			<xsl:when test="count(//elem[@mapping='repository']) &gt; 0">
				<xsl:value-of select="//elem[@mapping='repository'][1]"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="exsl:node-set($config)/config/template/repository"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>

	<!-- control variables -->
	<xsl:variable name="createdBy">
		<xsl:choose>
			<xsl:when test="string(exsl:node-set($config)/config/template/createdBy)">
				<xsl:value-of select="exsl:node-set($config)/config/template/createdBy"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>Record generated by CSV upload in Numishare.</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	<xsl:variable name="publisher" select="exsl:node-set($config)/config/template/agencyName"/>
	<xsl:variable name="copyrightHolder" select="exsl:node-set($config)/config/template/copyrightHolder"/>
	<xsl:variable name="language" select="exsl:node-set($config)/config/template/language"/>
	<xsl:variable name="langcode" select="exsl:node-set($config)/config/template/language/@langcode"/>

	<xsl:variable name="nomisma-labels">
		<ids>
			<xsl:for-each select="distinct-values(//elem[contains(@mapping, '-uri')])">
				<xsl:for-each select="tokenize(., '\|')">
					<xsl:variable name="uri" select="translate(normalize-space(.), '?', '')"/>
					<id href="{$uri}">
						<xsl:call-template name="get-nomisma-label">
							<xsl:with-param name="uri" select="$uri"/>
						</xsl:call-template>
					</id>
				</xsl:for-each>
			</xsl:for-each>
		</ids>
	</xsl:variable>


	<xsl:template match="/">
		<dsc>
			<xsl:apply-templates select="//row[not(position()=last())]"/>
		</dsc>
	</xsl:template>

	<xsl:template match="row">
		<nuds recordType="{elem[@mapping='recordType']}" xmlns="http://nomisma.org/nuds" xmlns:mets="http://www.loc.gov/METS/" xmlns:xlink="http://www.w3.org/1999/xlink"
			xmlns:gml="http://www.opengis.net/gml">
			<control>
				<recordId>
					<xsl:value-of select="normalize-space(elem[@mapping='recordId'])"/>
				</recordId>
				<publicationStmt>
					<publisher>
						<xsl:value-of select="$publisher"/>
					</publisher>
					<createdBy>
						<xsl:value-of select="$createdBy"/>
					</createdBy>
					<date normal="{substring(datetime:dateTime(), 1, 10)}"/>
					<langUsage>
						<language langcode="{$langcode}">
							<xsl:value-of select="$language"/>
						</language>
					</langUsage>
				</publicationStmt>
				<rightsStmt>
					<copyrightHolder>
						<xsl:value-of select="$copyrightHolder"/>
					</copyrightHolder>
					<date normal="{substring(datetime:dateTime(), 1, 4)}">
						<xsl:value-of select="substring(datetime:dateTime(), 1, 4)"/>
					</date>
				</rightsStmt>
			</control>
			<!-- descMeta -->
			<descMeta>
				<title>
					<!-- create title from id for OCRE -->
					<xsl:variable name="tokenized_id" select="tokenize(normalize-space(elem[@mapping='recordId']), '\.')"/>
					<xsl:variable name="authority-uri" select="normalize-space(translate(elem[@mapping='authority-personal-uri'], '?', ''))"/>
					
					<xsl:text>RIC </xsl:text>
					<xsl:choose>
						<xsl:when test="number(substring($tokenized_id[2], 1, 1)) = 1 and not(number(substring($tokenized_id[2], 1, 2)) = 10)">
							<xsl:text>I</xsl:text>
						</xsl:when>
						<xsl:when test="number(substring($tokenized_id[2], 1, 1)) = 2">
							<xsl:text>II</xsl:text>
						</xsl:when>
						<xsl:when test="number(substring($tokenized_id[2], 1, 1)) = 3">
							<xsl:text>II</xsl:text>
						</xsl:when>
						<xsl:when test="number(substring($tokenized_id[2], 1, 1)) = 4">
							<xsl:text>IV</xsl:text>
						</xsl:when>
						<xsl:when test="number(substring($tokenized_id[2], 1, 1)) = 5">
							<xsl:text>V</xsl:text>
						</xsl:when>
						<xsl:when test="number(substring($tokenized_id[2], 1, 1)) = 6">
							<xsl:text>VI</xsl:text>
						</xsl:when>
						<xsl:when test="number(substring($tokenized_id[2], 1, 1)) = 7">
							<xsl:text>VII</xsl:text>
						</xsl:when>
						<xsl:when test="number(substring($tokenized_id[2], 1, 1)) = 8">
							<xsl:text>VIII</xsl:text>
						</xsl:when>
						<xsl:when test="number(substring($tokenized_id[2], 1, 1)) = 9">
							<xsl:text>IX</xsl:text>
						</xsl:when>
						<xsl:when test="number(substring($tokenized_id[2], 1, 2)) = 10">
							<xsl:text>X</xsl:text>
						</xsl:when>
					</xsl:choose>
					<xsl:text> </xsl:text>
					<xsl:if test="contains($tokenized_id[2], '_')">
						<xsl:text>part </xsl:text>
						<xsl:value-of select="substring(substring-after($tokenized_id, '_'), 1, 1)"/>
						<xsl:text> </xsl:text>
					</xsl:if>
					<xsl:if test="contains($tokenized_id[2], '(2)')">
						<xsl:text>(second edition) </xsl:text>
					</xsl:if>
					<xsl:value-of select="exsl:node-set($nomisma-labels)/ids/id[@href=$authority-uri][1]"/>
					<xsl:text> </xsl:text>
					<xsl:value-of select="$tokenized_id[4]"/>
					
					<!-- commented out default title-->
					<!--<xsl:choose>
						<xsl:when test="string(elem[@mapping='title'])">
							<xsl:value-of select="elem[@mapping='title']"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:if test="string-length(elem[@mapping='material-uri']) &gt; 0">
								<xsl:for-each select="tokenize(elem[@mapping='material-uri'], '\|')">
									<xsl:variable name="uri" select="normalize-space(translate(., '?', ''))"/>
									<xsl:choose>
										<xsl:when test="contains(., 'nomisma')">
											<xsl:value-of select="exsl:node-set($nomisma-labels)/ids/id[@href=$uri][1]"/>
										</xsl:when>
									</xsl:choose>
									<xsl:if test="not(position()=last())">
										<xsl:text>/</xsl:text>
									</xsl:if>
								</xsl:for-each>
								<xsl:text> </xsl:text>
							</xsl:if>
							<xsl:choose>
								<xsl:when test="string-length(elem[@mapping='denomination-uri']) &gt; 0">
									<xsl:for-each select="tokenize(elem[@mapping='denomination-uri'], '\|')">
										<xsl:variable name="uri" select="normalize-space(translate(., '?', ''))"/>
										<xsl:choose>
											<xsl:when test="contains(., 'nomisma')">
												<xsl:value-of select="exsl:node-set($nomisma-labels)/ids/id[@href=$uri][1]"/>
											</xsl:when>
										</xsl:choose>
										<xsl:if test="not(position()=last())">
											<xsl:text>/</xsl:text>
										</xsl:if>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="elem[@mapping='objectType']"/>
								</xsl:otherwise>
							</xsl:choose>
							<xsl:if test="not(string(elem[@mapping='authority-personal-uri']) and string(elem[@mapping='mint-uri']))">
								<xsl:text>, </xsl:text>
							</xsl:if>
							<xsl:if test="string(elem[@mapping='authority-personal-uri']) or string(elem[@mapping='mint-uri'])">
								<xsl:text> of </xsl:text>
								<xsl:if test="string-length(elem[@mapping='authority-personal-uri']) &gt; 0">
									<xsl:for-each select="tokenize(elem[@mapping='authority-personal-uri'], '\|')">
										<xsl:variable name="uri" select="normalize-space(translate(., '?', ''))"/>
										<xsl:choose>
											<xsl:when test="contains(., 'nomisma')">
												<xsl:value-of select="exsl:node-set($nomisma-labels)/ids/id[@href=$uri][1]"/>
											</xsl:when>
										</xsl:choose>
										<xsl:if test="not(position()=last())">
											<xsl:text>/</xsl:text>
										</xsl:if>
									</xsl:for-each>
									<xsl:text>, </xsl:text>
								</xsl:if>
								<xsl:if test="string-length(elem[@mapping='mint-uri']) &gt; 0">
									<xsl:for-each select="tokenize(elem[@mapping='mint-uri'], '\|')">
										<xsl:variable name="uri" select="normalize-space(translate(., '?', ''))"/>
										<xsl:choose>
											<xsl:when test="contains(., 'nomisma')">
												<xsl:value-of select="exsl:node-set($nomisma-labels)/ids/id[@href=$uri][1]"/>
											</xsl:when>
										</xsl:choose>
										<xsl:if test="not(position()=last())">
											<xsl:text>/</xsl:text>
										</xsl:if>
									</xsl:for-each>
									<xsl:text>, </xsl:text>
								</xsl:if>
							</xsl:if>
							<xsl:if test="string(elem[@mapping='fromDate']) or string(elem[@mapping='toDate'])">
								<xsl:call-template name="date-string"/>
								<xsl:text>, </xsl:text>
							</xsl:if>
							<xsl:value-of select="normalize-space(elem[@mapping='recordId'])"/>
							<xsl:text>.</xsl:text>
						</xsl:otherwise>
					</xsl:choose>-->
				</title>

				<xsl:for-each select="elem[@mapping='department']">
					<xsl:if test="string(normalize-space(.))">
						<department>
							<xsl:value-of select="normalize-space(.)"/>
						</department>
					</xsl:if>
				</xsl:for-each>
				<xsl:for-each select="elem[@mapping='description']">
					<xsl:if test="string(normalize-space(.))">
						<description>
							<xsl:value-of select="normalize-space(.)"/>
						</description>
					</xsl:if>
				</xsl:for-each>
				<xsl:if test="count(elem[@mapping='subject']) &gt; 0">
					<subjectSet>
						<xsl:for-each select="elem[@mapping='subject']">
							<xsl:if test="string(normalize-space(.))">
								<subject>
									<xsl:value-of select="normalize-space(.)"/>
								</subject>
							</xsl:if>
						</xsl:for-each>
					</subjectSet>
				</xsl:if>

				<!-- typeDesc-->
				<xsl:choose>
					<!-- when there exists a typeDesc URI, use that and ignore other typological elems -->
					<xsl:when test="string(elem[@mapping='typeDesc-uri'])">
						<typeDesc xlink:href="normalize-space(elem[@mapping='typeDesc-uri'])"/>
					</xsl:when>
					<xsl:otherwise>
						<typeDesc>
							<!-- object type -->
							<xsl:call-template name="controlaccess">
								<xsl:with-param name="element">objectType</xsl:with-param>
								<xsl:with-param name="xlink:role"/>
								<xsl:with-param name="mapping">objectType</xsl:with-param>
							</xsl:call-template>

							<!-- denomination -->
							<xsl:call-template name="controlaccess">
								<xsl:with-param name="element">denomination</xsl:with-param>
								<xsl:with-param name="xlink:role"/>
								<xsl:with-param name="mapping">denomination</xsl:with-param>
							</xsl:call-template>

							<!-- material -->
							<xsl:call-template name="controlaccess">
								<xsl:with-param name="element">material</xsl:with-param>
								<xsl:with-param name="xlink:role"/>
								<xsl:with-param name="mapping">material</xsl:with-param>
							</xsl:call-template>

							<!-- call date template -->
							<xsl:call-template name="date"/>

							<!-- authority -->
							<xsl:if
								test="elem[contains(@mapping, 'artist') or contains(@mapping, 'authority') or contains(@mapping, 'engraver') or contains(@mapping, 'issuer') or contains(@mapping, 'magistrate') or contains(@mapping, 'maker') or contains(@mapping, 'famname')][string-length(normalize-space(.)) &gt; 0]">
								<authority>
									<!-- artist -->
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">persname</xsl:with-param>
										<xsl:with-param name="xlink:role">artist</xsl:with-param>
										<xsl:with-param name="mapping">artist</xsl:with-param>
									</xsl:call-template>
									<!-- authority-->
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">persname</xsl:with-param>
										<xsl:with-param name="xlink:role">authority</xsl:with-param>
										<xsl:with-param name="mapping">authority-personal</xsl:with-param>
									</xsl:call-template>
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">corpname</xsl:with-param>
										<xsl:with-param name="xlink:role">authority</xsl:with-param>
										<xsl:with-param name="mapping">authority-corporate</xsl:with-param>
									</xsl:call-template>
									<!-- dynasty -->
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">famname</xsl:with-param>
										<xsl:with-param name="xlink:role"/>
										<xsl:with-param name="mapping">famname</xsl:with-param>
									</xsl:call-template>
									<!-- engraver -->
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">persname</xsl:with-param>
										<xsl:with-param name="xlink:role">engraver</xsl:with-param>
										<xsl:with-param name="mapping">engraver</xsl:with-param>
									</xsl:call-template>
									<!-- issuer -->
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">persname</xsl:with-param>
										<xsl:with-param name="xlink:role">issuer</xsl:with-param>
										<xsl:with-param name="mapping">issuer-personal</xsl:with-param>
									</xsl:call-template>
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">corpname</xsl:with-param>
										<xsl:with-param name="xlink:role">issuer</xsl:with-param>
										<xsl:with-param name="mapping">issuer-corporate</xsl:with-param>
									</xsl:call-template>
									<!-- magistrate -->
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">persname</xsl:with-param>
										<xsl:with-param name="xlink:role">magistrate</xsl:with-param>
										<xsl:with-param name="mapping">magistrate</xsl:with-param>
									</xsl:call-template>
									<!-- maker -->
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">persname</xsl:with-param>
										<xsl:with-param name="xlink:role">maker</xsl:with-param>
										<xsl:with-param name="mapping">maker-personal</xsl:with-param>
									</xsl:call-template>
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">corpname</xsl:with-param>
										<xsl:with-param name="xlink:role">maker</xsl:with-param>
										<xsl:with-param name="mapping">maker-corporate</xsl:with-param>
									</xsl:call-template>
								</authority>
							</xsl:if>

							<!-- geographic -->
							<xsl:if
								test="count(elem[@mapping='mint'][string-length(normalize-space(.)) &gt; 0]) &gt; 0 or count(elem[@mapping='mint-uri'][string-length(normalize-space(.)) &gt; 0]) &gt; 0 or count(elem[@mapping='region'][string-length(normalize-space(.)) &gt; 0]) &gt; 0 or count(elem[@mapping='region-uri'][string-length(normalize-space(.)) &gt; 0]) &gt; 0">
								<geographic>
									<!-- mint -->
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">geogname</xsl:with-param>
										<xsl:with-param name="xlink:role">mint</xsl:with-param>
										<xsl:with-param name="mapping">mint</xsl:with-param>
									</xsl:call-template>
									<!-- region -->
									<xsl:call-template name="controlaccess">
										<xsl:with-param name="element">geogname</xsl:with-param>
										<xsl:with-param name="xlink:role">region</xsl:with-param>
										<xsl:with-param name="mapping">region</xsl:with-param>
									</xsl:call-template>
								</geographic>
							</xsl:if>


							<!-- obverse -->
							<xsl:if
								test="string(normalize-space(elem[@mapping='obverse-type'])) or string(normalize-space(elem[@mapping='obverse-legend'])) or string(normalize-space(elem[@mapping='obverse-symbol'])) or string(normalize-space(elem[@mapping='obverse-deity'])) or string(normalize-space(elem[@mapping='obverse-portrait'])) or string(normalize-space(elem[@mapping='obverse-portait-uri'])) or string(normalize-space(elem[@mapping='obverse-deity-uri']))">
								<obverse>
									<xsl:if test="string(normalize-space(elem[@mapping='obverse-type']))">
										<type>
											<xsl:value-of select="normalize-space(elem[@mapping='obverse-type'])"/>
										</type>
									</xsl:if>
									<xsl:if test="string(normalize-space(elem[@mapping='obverse-legend']))">
										<legend>
											<xsl:value-of select="normalize-space(elem[@mapping='obverse-legend'])"/>
										</legend>
									</xsl:if>
									<xsl:if test="string(normalize-space(elem[@mapping='obverse-symbol']))">
										<symbol>
											<xsl:value-of select="normalize-space(elem[@mapping='obverse-symbol'])"/>
										</symbol>
									</xsl:if>
									<!-- portrait -->
									<xsl:if test="string(normalize-space(elem[@mapping='obverse-portrait'][1])) or string(normalize-space(elem[@mapping='obverse-portait-uri'][1]))">
										<xsl:call-template name="controlaccess">
											<xsl:with-param name="element">persname</xsl:with-param>
											<xsl:with-param name="xlink:role">portrait</xsl:with-param>
											<xsl:with-param name="mapping">obverse-portrait</xsl:with-param>
										</xsl:call-template>
									</xsl:if>
									<!-- deity -->
									<xsl:if test="string(normalize-space(elem[@mapping='obverse-deity'][1])) or string(normalize-space(elem[@mapping='obverse-portait-uri'][1]))">
										<xsl:call-template name="controlaccess">
											<xsl:with-param name="element">persname</xsl:with-param>
											<xsl:with-param name="xlink:role">deity</xsl:with-param>
											<xsl:with-param name="mapping">obverse-deity</xsl:with-param>
										</xsl:call-template>
									</xsl:if>
									<!-- artist -->
									<xsl:if test="string(normalize-space(elem[@mapping='obverse-artist'][1])) or string(normalize-space(elem[@mapping='obverse-artist-uri'][1]))">
										<xsl:call-template name="controlaccess">
											<xsl:with-param name="element">persname</xsl:with-param>
											<xsl:with-param name="xlink:role">arist</xsl:with-param>
											<xsl:with-param name="mapping">obverse-artist</xsl:with-param>
										</xsl:call-template>
									</xsl:if>
									<!-- maker -->
									<xsl:if test="string(normalize-space(elem[@mapping='obverse-engraver'][1])) or string(normalize-space(elem[@mapping='obverse-engraver-uri'][1]))">
										<xsl:call-template name="controlaccess">
											<xsl:with-param name="element">persname</xsl:with-param>
											<xsl:with-param name="xlink:role">engraver</xsl:with-param>
											<xsl:with-param name="mapping">obverse-engraver</xsl:with-param>
										</xsl:call-template>
									</xsl:if>
								</obverse>
							</xsl:if>

							<!-- reverse -->
							<xsl:if
								test="string(normalize-space(elem[@mapping='reverse-type'])) or string(normalize-space(elem[@mapping='reverse-legend'])) or string(normalize-space(elem[@mapping='reverse-symbol'])) or string(normalize-space(elem[@mapping='reverse-deity'])) or string(normalize-space(elem[@mapping='reverse-portrait'])) or string(normalize-space(elem[@mapping='reverse-portait-uri'])) or string(normalize-space(elem[@mapping='reverse-deity-uri']))">
								<reverse>
									<xsl:if test="string(normalize-space(elem[@mapping='reverse-type']))">
										<type>
											<xsl:value-of select="normalize-space(elem[@mapping='reverse-type'])"/>
										</type>
									</xsl:if>
									<xsl:if test="string(normalize-space(elem[@mapping='reverse-legend']))">
										<legend>
											<xsl:value-of select="normalize-space(elem[@mapping='reverse-legend'])"/>
										</legend>
									</xsl:if>
									<xsl:if test="string(normalize-space(elem[@mapping='reverse-symbol']))">
										<symbol>
											<xsl:value-of select="normalize-space(elem[@mapping='reverse-symbol'])"/>
										</symbol>
									</xsl:if>
									<!-- portrait -->
									<xsl:if test="string(normalize-space(elem[@mapping='reverse-portrait'][1])) or string(normalize-space(elem[@mapping='reverse-portait-uri'][1]))">
										<xsl:call-template name="controlaccess">
											<xsl:with-param name="element">persname</xsl:with-param>
											<xsl:with-param name="xlink:role">portrait</xsl:with-param>
											<xsl:with-param name="mapping">reverse-portrait</xsl:with-param>
										</xsl:call-template>
									</xsl:if>
									<!-- deity -->
									<xsl:if test="string(normalize-space(elem[@mapping='reverse-deity'][1])) or string(normalize-space(elem[@mapping='reverse-portait-uri'][1]))">
										<xsl:call-template name="controlaccess">
											<xsl:with-param name="element">persname</xsl:with-param>
											<xsl:with-param name="xlink:role">deity</xsl:with-param>
											<xsl:with-param name="mapping">reverse-deity</xsl:with-param>
										</xsl:call-template>
									</xsl:if>
									<!-- artist -->
									<xsl:if test="string(normalize-space(elem[@mapping='reverse-artist'][1])) or string(normalize-space(elem[@mapping='reverse-artist-uri'][1]))">
										<xsl:call-template name="controlaccess">
											<xsl:with-param name="element">persname</xsl:with-param>
											<xsl:with-param name="xlink:role">arist</xsl:with-param>
											<xsl:with-param name="mapping">reverse-artist</xsl:with-param>
										</xsl:call-template>
									</xsl:if>
									<!-- maker -->
									<xsl:if test="string(normalize-space(elem[@mapping='reverse-engraver'][1])) or string(normalize-space(elem[@mapping='reverse-engraver-uri'][1]))">
										<xsl:call-template name="controlaccess">
											<xsl:with-param name="element">persname</xsl:with-param>
											<xsl:with-param name="xlink:role">engraver</xsl:with-param>
											<xsl:with-param name="mapping">reverse-engraver</xsl:with-param>
										</xsl:call-template>
									</xsl:if>
								</reverse>
							</xsl:if>

							<!-- edge -->
							<xsl:if
								test="string(normalize-space(elem[@mapping='edge-type'])) or string(normalize-space(elem[@mapping='edge-legend'])) or string(normalize-space(elem[@mapping='edge-description']))">
								<edge>
									<xsl:if test="string(normalize-space(elem[@mapping='edge-type']))">
										<type>
											<xsl:value-of select="normalize-space(elem[@mapping='edge-type'])"/>
										</type>
									</xsl:if>
									<xsl:if test="string(normalize-space(elem[@mapping='edge-legend']))">
										<legend>
											<xsl:value-of select="normalize-space(elem[@mapping='edge-legend'])"/>
										</legend>
									</xsl:if>
									<xsl:if test="string(normalize-space(elem[@mapping='edge-description']))">
										<description>
											<xsl:value-of select="normalize-space(elem[@mapping='edge-description'])"/>
										</description>
									</xsl:if>
								</edge>
							</xsl:if>
						</typeDesc>
					</xsl:otherwise>
				</xsl:choose>

				<!-- only create other descriptive elements if the recordType is physical -->
				<xsl:if test="elem[@mapping='recordType']='physical'">
					<!-- physDesc -->
					<physDesc>
						<xsl:if test="string(normalize-space(elem[@mapping='axis']))">
							<axis>
								<xsl:value-of select="normalize-space(elem[@mapping='axis'])"/>
							</axis>
						</xsl:if>
						<!--<xsl:for-each select="elem[@mapping='color']">
								<xsl:if test="string(normalize-space(.))">
									<color>
										<xsl:value-of select="normalize-space(.)"/>
									</color>
								</xsl:if>
							</xsl:for-each>-->
						<xsl:if test="string(normalize-space(elem[@mapping='dob']))">
							<dateOnObject>
								<date normal="">
									<xsl:value-of select="normalize-space(elem[@mapping='dob'])"/>
								</date>
							</dateOnObject>
						</xsl:if>
						<!-- conservationState -->
						<xsl:if
							test="string(normalize-space(elem[@mapping='completeness'])) or string(normalize-space(elem[@mapping='condition'])) or string(normalize-space(elem[@mapping='grade'])) or string(normalize-space(elem[@mapping='wear'])) or string(normalize-space(elem[@mapping='obverse-completeness'])) or string(normalize-space(elem[@mapping='obverse-condition'])) or string(normalize-space(elem[@mapping='obverse-grade'])) or string(normalize-space(elem[@mapping='obverse-wear'])) or string(normalize-space(elem[@mapping='reverse-completeness'])) or string(normalize-space(elem[@mapping='reverse-condition'])) or string(normalize-space(elem[@mapping='reverse-grade'])) or string(normalize-space(elem[@mapping='reverse-wear']))">
							<conservationState>
								<xsl:if test="string(normalize-space(elem[@mapping='completeness']))">
									<completeness>
										<xsl:value-of select="normalize-space(elem[@mapping='completeness'])"/>
									</completeness>
								</xsl:if>
								<xsl:if test="string(normalize-space(elem[@mapping='condition']))">
									<condition>
										<xsl:value-of select="normalize-space(elem[@mapping='condition'])"/>
									</condition>
								</xsl:if>
								<xsl:if test="string(normalize-space(elem[@mapping='grade']))">
									<grade>
										<xsl:value-of select="normalize-space(elem[@mapping='grade'])"/>
									</grade>
								</xsl:if>
								<xsl:if test="string(normalize-space(elem[@mapping='wear']))">
									<wear>
										<xsl:value-of select="normalize-space(elem[@mapping='wear'])"/>
									</wear>
								</xsl:if>
								<xsl:if
									test="string(normalize-space(elem[@mapping='obverse-completeness'])) or string(normalize-space(elem[@mapping='obverse-condition'])) or string(normalize-space(elem[@mapping='obverse-grade'])) or string(normalize-space(elem[@mapping='obverse-wear']))">
									<obverse>
										<xsl:if test="string(normalize-space(elem[@mapping='obverse-completeness']))">
											<completeness>
												<xsl:value-of select="normalize-space(elem[@mapping='obverse-completeness'])"/>
											</completeness>
										</xsl:if>
										<xsl:if test="string(normalize-space(elem[@mapping='obverse-condition']))">
											<condition>
												<xsl:value-of select="normalize-space(elem[@mapping='obverse-condition'])"/>
											</condition>
										</xsl:if>
										<xsl:if test="string(normalize-space(elem[@mapping='obverse-grade']))">
											<grade>
												<xsl:value-of select="normalize-space(elem[@mapping='obverse-grade'])"/>
											</grade>
										</xsl:if>
										<xsl:if test="string(normalize-space(elem[@mapping='obverse-wear']))">
											<wear>
												<xsl:value-of select="normalize-space(elem[@mapping='obverse-wear'])"/>
											</wear>
										</xsl:if>
									</obverse>
								</xsl:if>
								<xsl:if
									test="string(normalize-space(elem[@mapping='reverse-completeness'])) or string(normalize-space(elem[@mapping='reverse-condition'])) or string(normalize-space(elem[@mapping='reverse-grade'])) or string(normalize-space(elem[@mapping='reverse-wear']))">
									<reverse>
										<xsl:if test="string(normalize-space(elem[@mapping='reverse-completeness']))">
											<completeness>
												<xsl:value-of select="normalize-space(elem[@mapping='reverse-completeness'])"/>
											</completeness>
										</xsl:if>
										<xsl:if test="string(normalize-space(elem[@mapping='reverse-condition']))">
											<condition>
												<xsl:value-of select="normalize-space(elem[@mapping='reverse-condition'])"/>
											</condition>
										</xsl:if>
										<xsl:if test="string(normalize-space(elem[@mapping='reverse-grade']))">
											<grade>
												<xsl:value-of select="normalize-space(elem[@mapping='reverse-grade'])"/>
											</grade>
										</xsl:if>
										<xsl:if test="string(normalize-space(elem[@mapping='reverse-wear']))">
											<wear>
												<xsl:value-of select="normalize-space(elem[@mapping='reverse-wear'])"/>
											</wear>
										</xsl:if>
									</reverse>
								</xsl:if>
							</conservationState>
						</xsl:if>

						<!-- countermark -->
						<xsl:if
							test="string(normalize-space(elem[@mapping='countermark-description'])) or string(normalize-space(elem[@mapping='countermark-obverse'])) or string(normalize-space(elem[@mapping='countermark-reverse']))">
							<countermark>
								<xsl:if test="string(normalize-space(elem[@mapping='countermark-description']))">
									<description>
										<xsl:value-of select="normalize-space(elem[@mapping='countermark-description'])"/>
									</description>
								</xsl:if>
								<xsl:if test="string(normalize-space(elem[@mapping='countermark-obverse']))">
									<obverse>
										<xsl:value-of select="normalize-space(elem[@mapping='countermark-obverse'])"/>
									</obverse>
								</xsl:if>
								<xsl:if test="string(normalize-space(elem[@mapping='countermark-reverse']))">
									<reverse>
										<xsl:value-of select="normalize-space(elem[@mapping='countermark-reverse'])"/>
									</reverse>
								</xsl:if>
							</countermark>
						</xsl:if>

						<!-- measurementsSet -->
						<xsl:if
							test="string(normalize-space(elem[@mapping='diameter'])) or string(normalize-space(elem[@mapping='height'])) or string(normalize-space(elem[@mapping='thickness'])) or string(normalize-space(elem[@mapping='weight'])) or string(normalize-space(elem[@mapping='width']))">
							<measurementsSet>
								<xsl:if test="string(normalize-space(elem[@mapping='diameter']))">
									<diameter>
										<xsl:value-of select="normalize-space(elem[@mapping='diameter'])"/>
									</diameter>
								</xsl:if>
								<xsl:if test="string(normalize-space(elem[@mapping='height']))">
									<height>
										<xsl:value-of select="normalize-space(elem[@mapping='height'])"/>
									</height>
								</xsl:if>
								<xsl:if test="string(normalize-space(elem[@mapping='thickness']))">
									<thickness>
										<xsl:value-of select="normalize-space(elem[@mapping='thickness'])"/>
									</thickness>
								</xsl:if>
								<xsl:if test="string(normalize-space(elem[@mapping='weight']))">
									<weight>
										<xsl:value-of select="normalize-space(elem[@mapping='weight'])"/>
									</weight>
								</xsl:if>
								<xsl:if test="string(normalize-space(elem[@mapping='width']))">
									<width>
										<xsl:value-of select="normalize-space(elem[@mapping='width'])"/>
									</width>
								</xsl:if>
							</measurementsSet>
							<xsl:if test="string(normalize-space(elem[@mapping='shape']))">
								<shape>
									<xsl:value-of select="normalize-space(elem[@mapping='shape'])"/>
								</shape>
							</xsl:if>
						</xsl:if>
					</physDesc>
					<!-- adminDesc -->
					<adminDesc>
						<!--<xsl:if test="string(normalize-space(elem[@mapping='acqinfo']))">
								<acqinfo>
									<p>
										<xsl:value-of select="normalize-space(elem[@mapping='acqinfo'])"/>
									</p>
								</acqinfo>
							</xsl:if>-->
						<xsl:for-each select="elem[@mapping='acknowledgment'][string-length() &gt; 0]">
							<acknowledgment>
								<xsl:value-of select="normalize-space(.)"/>
							</acknowledgment>
						</xsl:for-each>
						<xsl:if test="string(normalize-space(elem[@mapping='appraisal-date'])) or string(normalize-space(elem[@mapping='appraiser']))">
							<appraisal>
								<xsl:if test="string(normalize-space(elem[@mapping='appraisal-date']))">
									<date>
										<xsl:value-of select="normalize-space(elem[@mapping='appraisal-date'])"/>
									</date>
								</xsl:if>
								<xsl:if test="string(normalize-space(elem[@mapping='appraiser']))">
									<appraiser>
										<xsl:value-of select="normalize-space(elem[@mapping='appraiser'])"/>
									</appraiser>
								</xsl:if>
							</appraisal>
						</xsl:if>
						<xsl:if test="string(normalize-space($collection))">
							<collection>
								<xsl:value-of select="normalize-space($collection)"/>
							</collection>
						</xsl:if>
						<xsl:if test="string(normalize-space(elem[@mapping='identifier']))">
							<identifier>
								<xsl:value-of select="normalize-space(elem[@mapping='identifier'])"/>
							</identifier>
						</xsl:if>
						<xsl:if test="string(normalize-space($owner))">
							<owner>
								<xsl:value-of select="normalize-space($owner)"/>
							</owner>
						</xsl:if>
						<xsl:if test="string(normalize-space(elem[@mapping='physloc']))">
							<physloc>
								<xsl:value-of select="normalize-space(elem[@mapping='physloc'])"/>
							</physloc>
						</xsl:if>
						<!--<xsl:if test="string(normalize-space(elem[@mapping='custodhist']))">
								<custodhist>
									<p>
										<xsl:value-of select="normalize-space(elem[@mapping='custodhist'])"/>
									</p>
								</custodhist>
							</xsl:if>-->
						<xsl:if test="string(normalize-space($repository))">
							<repository>
								<xsl:value-of select="normalize-space($repository)"/>
							</repository>
						</xsl:if>
					</adminDesc>
				</xsl:if>
			</descMeta>

			<!-- enable associated objects only for conceptual records -->
			<xsl:if test="string(normalize-space(elem[@mapping='associatedObject'])) and elem[@mapping='recordType'] = 'conceptual'">
				<digRep>
					<associatedObject xlink:href="{normalize-space(elem[@mapping='associatedObject'])}"/>
				</digRep>
			</xsl:if>

			<!-- only import images if the recordType is physical -->
			<xsl:if test="elem[@mapping='recordType']='physical'">
				<xsl:if test="elem[contains(@mapping, 'image-')][string-length(normalize-space(.)) &gt; 0]">
					<digRep>
						<mets:fileSec>
							<xsl:if test="elem[contains(@mapping, 'image-obverse-')][string-length(normalize-space(.)) &gt; 0]">
								<mets:fileGrp USE="obverse">
									<xsl:if test="elem[@mapping='image-obverse-thumbnail'][string-length(normalize-space(.)) &gt; 0]">
										<mets:file USE="thumbnail">
											<mets:FLocat LOCTYPE="URL" xlink:href="{elem[@mapping='image-obverse-thumbnail']}"/>
										</mets:file>
									</xsl:if>
									<xsl:if test="elem[@mapping='image-obverse-reference'][string-length(normalize-space(.)) &gt; 0]">
										<mets:file USE="reference">
											<mets:FLocat LOCTYPE="URL" xlink:href="{elem[@mapping='image-obverse-reference']}"/>
										</mets:file>
									</xsl:if>
									<xsl:if test="elem[@mapping='image-obverse-archive'][string-length(normalize-space(.)) &gt; 0]">
										<mets:file USE="archive">
											<mets:FLocat LOCTYPE="URL" xlink:href="{elem[@mapping='image-obverse-archive']}"/>
										</mets:file>
									</xsl:if>
								</mets:fileGrp>
							</xsl:if>
							<xsl:if test="elem[contains(@mapping, 'image-reverse-')][string-length(normalize-space(.)) &gt; 0]">
								<mets:fileGrp USE="reverse">
									<xsl:if test="elem[@mapping='image-obverse-thumbnail'][string-length(normalize-space(.)) &gt; 0]">
										<mets:file USE="thumbnail">
											<mets:FLocat LOCTYPE="URL" xlink:href="{elem[@mapping='image-obverse-thumbnail']}"/>
										</mets:file>
									</xsl:if>
									<xsl:if test="elem[@mapping='image-obverse-reference'][string-length(normalize-space(.)) &gt; 0]">
										<mets:file USE="reference">
											<mets:FLocat LOCTYPE="URL" xlink:href="{elem[@mapping='image-obverse-reference']}"/>
										</mets:file>
									</xsl:if>
									<xsl:if test="elem[@mapping='image-obverse-archive'][string-length(normalize-space(.)) &gt; 0]">
										<mets:file USE="archive">
											<mets:FLocat LOCTYPE="URL" xlink:href="{elem[@mapping='image-obverse-archive']}"/>
										</mets:file>
									</xsl:if>
								</mets:fileGrp>
							</xsl:if>
						</mets:fileSec>
					</digRep>
				</xsl:if>
			</xsl:if>
			<!--<xsl:if test="string(normalize-space(elem[@mapping='ref'])) or string(normalize-space(elem[@mapping='bibref-title'])) or string(normalize-space(elem[@mapping='bibref-num']))">
					<bibliography>
						<xsl:for-each select="elem[@mapping='ref']">
							<xsl:if test="string(normalize-space(.))">
								<ref show="new" actuate="onrequest" href="{normalize-space(.)}"/>
							</xsl:if>
						</xsl:for-each>
						<xsl:if test="string(normalize-space(elem[@mapping='bibref-title'])) or string(normalize-space(elem[@mapping='bibref-num']))">
							<bibref>
								<title render="italic">
									<xsl:value-of select="normalize-space(elem[@mapping='bibref-title'])"/>
								</title>
								<num type="idno">
									<xsl:value-of select="normalize-space(elem[@mapping='bibref-num'])"/>
								</num>
							</bibref>
						</xsl:if>
					</bibliography>
				</xsl:if>-->


		</nuds>

	</xsl:template>

	<xsl:template name="date">
		<xsl:variable name="normal">
			<xsl:choose>
				<xsl:when test="(number(elem[@mapping='fromDate']) and number(elem[@mapping='toDate'])) and number(elem[@mapping='fromDate']) != number(elem[@mapping='toDate'])">
					<xsl:value-of select="numishare:pad-year(elem[@mapping='fromDate'])"/>
					<xsl:text>/</xsl:text>
					<xsl:value-of select="numishare:pad-year(elem[@mapping='toDate'])"/>
				</xsl:when>
				<xsl:when test="(number(elem[@mapping='fromDate']) and number(elem[@mapping='toDate'])) and number(elem[@mapping='fromDate']) = number(elem[@mapping='toDate'])">
					<xsl:value-of select="numishare:pad-year(elem[@mapping='fromDate'])"/>
				</xsl:when>
				<xsl:when test="number(elem[@mapping='fromDate']) and not(number(elem[@mapping='toDate']))">
					<xsl:value-of select="numishare:pad-year(elem[@mapping='fromDate'])"/>
				</xsl:when>
				<xsl:when test="not(number(elem[@mapping='fromDate'])) and number(elem[@mapping='toDate'])">
					<xsl:value-of select="numishare:pad-year(elem[@mapping='toDate'])"/>
				</xsl:when>
			</xsl:choose>
		</xsl:variable>

		<xsl:if test="string($normal)">
			<date normal="{$normal}">
				<xsl:call-template name="date-string"/>
			</date>
		</xsl:if>
	</xsl:template>

	<xsl:template name="date-string">
		<xsl:variable name="fromDate" select="elem[@mapping='fromDate']"/>
		<xsl:variable name="toDate" select="elem[@mapping='toDate']"/>
		<xsl:variable name="from-era"
			select="if (number($fromDate) &lt; 0) then concat(abs(number($fromDate)), ' B.C.') else if (number($fromDate) &gt; 0 and number($fromDate) &lt; 400) then concat('A.D. ', number($fromDate)) else number($fromDate)"/>
		<xsl:variable name="to-era"
			select="if (number($toDate) &lt; 0) then concat(abs(number($toDate)), ' B.C.') else if (number($toDate) &gt; 0 and number($toDate) &lt; 400) then concat('A.D. ', number($toDate)) else number($toDate)"/>
		<xsl:value-of select="concat($from-era, if(number($fromDate) != number($toDate)) then ' - ' else '', if(number($fromDate) != number($toDate)) then $to-era else '')"/>
	</xsl:template>

	<xsl:template name="controlaccess">
		<xsl:param name="element"/>
		<xsl:param name="xlink:role"/>
		<xsl:param name="mapping"/>

		<xsl:variable name="uri-mapping">
			<xsl:value-of select="concat($mapping, '-uri')"/>
		</xsl:variable>

		<xsl:if test="string-length(elem[@mapping=$mapping][1]) &gt; 0">
			<xsl:for-each select="elem[@mapping=$mapping]">
				<xsl:for-each select="tokenize(., '\|')">
					<xsl:element name="{$element}">
						<xsl:if test="string($xlink:role)">
							<xsl:attribute name="xlink:role" select="$xlink:role"/>
						</xsl:if>
						<xsl:if test="contains(., '?')">
							<xsl:attribute name="certainty">uncertain</xsl:attribute>
						</xsl:if>
						<!-- suppress question mark -->
						<xsl:value-of select="normalize-space(translate(., '?', ''))"/>
					</xsl:element>
				</xsl:for-each>
			</xsl:for-each>
		</xsl:if>

		<!-- if there are uris for given field -->
		<xsl:if test="count(elem[@mapping=$mapping][string-length(normalize-space(.)) &gt; 0]) = 0">
			<xsl:for-each select="elem[@mapping=$uri-mapping]">
				<xsl:for-each select="tokenize(., '\|')">
					<xsl:element name="{$element}">
						<!-- replace ? for uncertainty with nothin -->
						<xsl:variable name="uri" select="normalize-space(translate(., '?', ''))"/>
						<xsl:if test="string($xlink:role)">
							<xsl:attribute name="xlink:role" select="$xlink:role"/>
						</xsl:if>
						<xsl:if test="contains($uri, 'http://')">
							<xsl:attribute name="xlink:href" select="$uri"/>
						</xsl:if>
						<xsl:if test="contains(., '?')">
							<xsl:attribute name="certainty">uncertain</xsl:attribute>
						</xsl:if>
						<!-- extract value from nomisma or geonames, if applicable-->
						<xsl:choose>
							<xsl:when test="contains(., 'nomisma')">
								<xsl:value-of select="exsl:node-set($nomisma-labels)/ids/id[@href=$uri][1]"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="normalize-space(translate(., '?', ''))"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:element>
				</xsl:for-each>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>

	<xsl:template name="get-nomisma-label" xmlns:skos="http://www.w3.org/2004/02/skos/core#">
		<xsl:param name="uri"/>
		<xsl:variable name="rdf_url" select="concat('http://www.w3.org/2012/pyRdfa/extract?format=xml&amp;uri=', encode-for-uri($uri))"/>

		<xsl:value-of select="document($rdf_url)//skos:prefLabel[@xml:lang='en']"/>
	</xsl:template>

	<xsl:function name="numishare:pad-year" xmlns:functx="http://www.functx.com">
		<xsl:param name="year" as="xs:integer"/>
		<xsl:variable name="bc-date">
			<xsl:if test="$year &lt; 0">true</xsl:if>
		</xsl:variable>
		<xsl:variable name="abs-year" select="string(abs($year))"/>
		<xsl:variable name="length" select="string-length($abs-year)"/>
		<xsl:variable name="difference" select="4 - $length"/>
		<xsl:variable name="padding">
			<xsl:call-template name="RepeatString">
				<xsl:with-param name="times" select="$difference"/>
			</xsl:call-template>
		</xsl:variable>

		<xsl:value-of select="concat(if ($bc-date = 'true') then '-' else '', $padding, $abs-year)"/>
	</xsl:function>

	<!-- from http://stackoverflow.com/questions/3228270/transform-an-integer-value-to-a-repeated-character -->
	<xsl:template name="RepeatString">
		<xsl:param name="times" select="1"/>
		<xsl:variable name="string" select="'0'"/>

		<xsl:if test="number($times) &gt; 0">
			<xsl:value-of select="$string"/>
			<xsl:call-template name="RepeatString">
				<xsl:with-param name="times" select="$times - 1"/>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>
</xsl:stylesheet>
