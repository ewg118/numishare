<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xforms="http://www.w3.org/2002/xforms"
	xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ev="http://www.w3.org/2001/xml-events" xmlns:xxf="http://orbeon.org/oxf/xml/xforms"
	xmlns:fr="http://orbeon.org/oxf/xml/form-runner" xmlns:numishare="https://github.comu/ewg118/numishare" xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:nuds="http://nomisma.org/nuds" xmlns:res="http://www.w3.org/2005/sparql-results#" xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:nm="http://nomisma.org/id/" xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	xmlns:skos="http://www.w3.org/2004/02/skos/core#" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:prov="http://www.w3.org/ns/prov#"
	xmlns:rdac="http://www.rdaregistry.info/Elements/c/" xmlns:nmo="http://nomisma.org/ontology#" xmlns:exist="http://exist.sourceforge.net/NS/exist">
	<head>
		<title>Numishare: Import Data from CSV</title>
		<link rel="stylesheet" href="/fr/style/bootstrap/css/bootstrap.css" type="text/css" />
		<link rel="stylesheet" href="/fr/style/form-runner-bootstrap-override.css" type="text/css" />
		<link rel="shortcut icon" href="/ops/images/orbeon-icon-16.ico" />
		<link rel="icon" href="/ops/images/orbeon-icon-16.png" type="image/png" />
		<link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" />
		<script type="text/javascript" src="https://netdna.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
		<link rel="stylesheet" href="/apps/numishare/xforms/css/xforms.css" />

		<xforms:model xmlns="http://nomisma.org/nuds">
			<xforms:instance id="nuds"
				xxf:exclude-result-prefixes="xhtml xforms xxforms ev xs xi xsi fr oxf nuds numishare exist res nm foaf rdf skos atom prov nmo rdac">
				<nuds recordType="" xmlns="http://nomisma.org/nuds" xmlns:tei="http://www.tei-c.org/ns/1.0" xmlns:mets="http://www.loc.gov/METS/"
					xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:gml="http://www.opengis.net/gml"> </nuds>
			</xforms:instance>

			<!-- xhtml xforms xxforms ev xs xi xsi fr oxf foaf rdf skos atom prov nmo nm res nuds numishare exist -->

			<!-- configurations and form controls -->
			<xforms:instance id="control-instance" xxf:exclude-result-prefixes="#all">
				<controls xmlns="">
					<status/>
					<collection-name/>
					<username/>
					<spreadsheet-key/>
					<spreadsheet-uri/>
					<worksheet_id/>
					<sheets-api-action/>
					<sheets-api-url/>
					<language>en</language>
					<nomisma-uri/>
					<rdf-api/>
					<id/>
					<target-id/>
					<position>0</position>
					<identifiers/>
					<mapping/>
					<mappings-valid>false</mappings-valid>
					<metadata-valid>false</metadata-valid>
					<load-trigger>false</load-trigger>
					<validate-trigger>false</validate-trigger>
					<import-trigger>false</import-trigger>
					<exactMatch-reference>true</exactMatch-reference>
					<link-to-coinType>true</link-to-coinType>
					<index-to-solr>true</index-to-solr>
					<validate-ids>true</validate-ids>
					<deprecate-ids>false</deprecate-ids>
				</controls>
			</xforms:instance>

			<!-- exist URL is stored in an XML file -->
			<xforms:instance id="exist-config">
				<xi:include href="../exist-config.xml"/>
			</xforms:instance>
			<!-- load URLs from config.xml in eXist into form for Solr and CSS file -->
			<xforms:instance id="config">
				<config xmlns=""/>
			</xforms:instance>

			<xforms:instance id="collections-list">
				<collections xmlns=""/>
			</xforms:instance>

			<!-- Nomisma RDF -->
			<xforms:instance id="rdf-concept" xxf:exclude-result-prefixes="#default xhtml xforms xs ev xxforms fr res xi nomisma atom">
				<rdf:RDF xmlns="" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:nm="http://nomisma.org/id/" xmlns:nmo="http://nomisma.org/ontology#"
					xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
					xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:skos="http://www.w3.org/2004/02/skos/core#"
					xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
					xmlns:un="http://www.owl-ontologies.com/Ontology1181490123.owl#" xmlns:osgeo="http://data.ordnancesurvey.co.uk/ontology/geometry/"
					xmlns:org="http://www.w3.org/ns/org#" xmlns:rdac="http://www.rdaregistry.info/Elements/c/" xmlns:bio="http://purl.org/vocab/bio/0.1/"
					xmlns:prov="http://www.w3.org/ns/prov#" xmlns:crm="http://www.cidoc-crm.org/cidoc-crm/"/>
			</xforms:instance>

			<xforms:instance id="rdf" xxf:exclude-result-prefixes="#default xhtml xforms xs ev xxforms fr res xi nomisma atom">
				<rdf:RDF xmlns="" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:nm="http://nomisma.org/id/" xmlns:nmo="http://nomisma.org/ontology#"
					xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
					xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:skos="http://www.w3.org/2004/02/skos/core#"
					xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
					xmlns:un="http://www.owl-ontologies.com/Ontology1181490123.owl#" xmlns:osgeo="http://data.ordnancesurvey.co.uk/ontology/geometry/"
					xmlns:org="http://www.w3.org/ns/org#" xmlns:rdac="http://www.rdaregistry.info/Elements/c/" xmlns:bio="http://purl.org/vocab/bio/0.1/"
					xmlns:prov="http://www.w3.org/ns/prov#" xmlns:crm="http://www.cidoc-crm.org/cidoc-crm/"/>
			</xforms:instance>

			<!-- NUDS templates -->
			<xforms:instance id="descMeta-template" xxf:exclude-result-prefixes="#all">
				<descMeta>
					<typeDesc/>
				</descMeta>
			</xforms:instance>

			<!-- ***** CONTROL TEMPLATES ***** -->
			<xforms:instance id="control-template" xxf:exclude-result-prefixes="#all">
				<control>
					<recordId/>
					<publicationStatus/>
					<maintenanceStatus/>
					<maintenanceAgency>
						<agencyName/>
					</maintenanceAgency>
					<maintenanceHistory>
						<maintenanceEvent>
							<eventType>derived</eventType>
							<eventDateTime standardDateTime=""/>
							<agentType>human</agentType>
							<agent/>
							<eventDescription>NUDS record created through Numishare spreadsheet import.</eventDescription>
							<source/>
						</maintenanceEvent>
					</maintenanceHistory>
					<rightsStmt/>
					<semanticDeclaration>
						<prefix>nmo</prefix>
						<namespace>http://nomisma.org/ontology#</namespace>
					</semanticDeclaration>
					<semanticDeclaration>
						<prefix>skos</prefix>
						<namespace>http://www.w3.org/2004/02/skos/core#</namespace>
					</semanticDeclaration>
					<semanticDeclaration>
						<prefix>dcterms</prefix>
						<namespace>http://purl.org/dc/terms/</namespace>
					</semanticDeclaration>
				</control>
			</xforms:instance>

			<xforms:instance id="otherRecordId-template" xxf:exclude-result-prefixes="#all">
				<otherRecordId/>
			</xforms:instance>

			<!-- ***** DESCMETA ***** -->
			<xforms:instance id="title-template" xxf:exclude-result-prefixes="#all">
				<title xml:lang=""/>
			</xforms:instance>

			<!-- typeDesc templates -->
			<xforms:instance id="authority-template" xxf:exclude-result-prefixes="#all">
				<authority/>
			</xforms:instance>

			<xforms:instance id="corpname-template" xxf:exclude-result-prefixes="#all">
				<corpname xlink:type="simple" xlink:role="" xlink:href=""/>
			</xforms:instance>

			<xforms:instance id="date-template" xxf:exclude-result-prefixes="#all">
				<date standardDate=""/>
			</xforms:instance>

			<xforms:instance id="dateRange-template" xxf:exclude-result-prefixes="#all">
				<dateRange>
					<fromDate standardDate=""/>
					<toDate standardDate=""/>
				</dateRange>
			</xforms:instance>

			<xforms:instance id="denomination-template" xxf:exclude-result-prefixes="#all">
				<denomination xlink:type="simple" xlink:href=""/>
			</xforms:instance>

			<xforms:instance id="description-template" xxf:exclude-result-prefixes="#all">
				<description xml:lang=""/>
			</xforms:instance>

			<xforms:instance id="die-template" xxf:exclude-result-prefixes="#all">
				<die state="nonexistent"/>
			</xforms:instance>

			<xforms:instance id="famname-template" xxf:exclude-result-prefixes="#all">
				<famname xlink:type="simple" xlink:role="" xlink:href=""/>
			</xforms:instance>

			<xforms:instance id="geogname-template" xxf:exclude-result-prefixes="#all">
				<geogname xlink:type="simple" xlink:role="" xlink:href=""/>
			</xforms:instance>

			<xforms:instance id="geographic-template" xxf:exclude-result-prefixes="#all">
				<geographic/>
			</xforms:instance>

			<xforms:instance id="legend-template" xxf:exclude-result-prefixes="#all">
				<legend/>
			</xforms:instance>

			<xforms:instance id="manufacture-template" xxf:exclude-result-prefixes="#all">
				<manufacture xlink:type="simple" xlink:href=""/>
			</xforms:instance>

			<xforms:instance id="material-template" xxf:exclude-result-prefixes="#all">
				<material xlink:type="simple" xlink:href=""/>
			</xforms:instance>

			<xforms:instance id="noteSet-template" xxf:exclude-result-prefixes="#all">
				<noteSet/>
			</xforms:instance>

			<xforms:instance id="note-template" xxf:exclude-result-prefixes="#all">
				<note xml:lang=""/>
			</xforms:instance>

			<xforms:instance id="objectType-template" xxf:exclude-result-prefixes="#all">
				<objectType xlink:type="simple" xlink:href=""/>
			</xforms:instance>

			<xforms:instance id="obverse-template" xxf:exclude-result-prefixes="#all">
				<obverse/>
			</xforms:instance>

			<xforms:instance id="persname-template" xxf:exclude-result-prefixes="#all">
				<persname xlink:type="simple" xlink:role="" xlink:href=""/>
			</xforms:instance>

			<xforms:instance id="reverse-template" xxf:exclude-result-prefixes="#all">
				<reverse/>
			</xforms:instance>

			<xforms:instance id="symbol-template" xxf:exclude-result-prefixes="#all">
				<symbol/>
			</xforms:instance>

			<xforms:instance id="type-template" xxf:exclude-result-prefixes="#all">
				<type/>
			</xforms:instance>

			<xforms:instance id="typeSeries-template" xxf:exclude-result-prefixes="#all">
				<typeSeries xlink:type="simple" xlink:href=""/>
			</xforms:instance>

			<!-- physDesc templates -->
			<xforms:instance id="physDesc-template" xxf:exclude-result-prefixes="#all">
				<physDesc/>
			</xforms:instance>

			<xforms:instance id="measurementsSet-template" xxf:exclude-result-prefixes="#all">
				<measurementsSet/>
			</xforms:instance>

			<xforms:instance id="axis-template" xxf:exclude-result-prefixes="#all">
				<axis/>
			</xforms:instance>

			<xforms:instance id="diameter-template" xxf:exclude-result-prefixes="#all">
				<diameter units="mm"/>
			</xforms:instance>

			<xforms:instance id="height-template" xxf:exclude-result-prefixes="#all">
				<height units="mm"/>
			</xforms:instance>

			<xforms:instance id="thickness-template" xxf:exclude-result-prefixes="#all">
				<thickness units="mm"/>
			</xforms:instance>

			<xforms:instance id="weight-template" xxf:exclude-result-prefixes="#all">
				<weight units="g"/>
			</xforms:instance>

			<xforms:instance id="width-template" xxf:exclude-result-prefixes="#all">
				<width units="mm"/>
			</xforms:instance>

			<!-- refDesc templates -->
			<xforms:instance id="refDesc-template" xxf:exclude-result-prefixes="#all">
				<refDesc/>
			</xforms:instance>

			<xforms:instance id="reference-template" xxf:exclude-result-prefixes="#all">
				<reference/>
			</xforms:instance>

			<!-- dump instance necessary for saving files to the disk -->
			<xforms:instance id="dump">
				<dump xmlns=""/>
			</xforms:instance>

			<!-- NUDS mappings and validation -->
			<xforms:instance id="properties" xxf:exclude-result-prefixes="#all">
				<properties xmlns="">
					<property label="Authority URI">auth_authority_uri</property>
					<property label="Axis" constraint="object">axis</property>
					<property label="Coin Type URI" constraint="object">coinType</property>
					<property label="Date On Object">dateOnObject</property>
					<property label="Diameter" constraint="object">diameter</property>
					<property label="Denomination URI">denomination_uri</property>
					<property label="Date Certainty">dateCertainty</property>
					<property label="End Date">toDate</property>
					<property label="Exatch Match URI" constraint="cointype">exactMatch</property>
					<property label="Issuer URI">auth_issuer_uri</property>
					<property label="Height" constraint="object">height</property>
					<property label="Manufacture URI">manufacture_uri</property>
					<property label="Material URI">material_uri</property>
					<property label="Mint URI">geo_mint_uri</property>
					<property label="Note">note</property>
					<property label="Object Type URI">objectType_uri</property>
					<property label="Obverse Deity URI">obv_deity_uri</property>
					<property label="Obverse Die ID">obv_die</property>
					<property label="Obverse Legend">obv_legend</property>
					<property label="Obverse Portrait URI">obv_portrait_uri</property>
					<property label="Obverse Symbol">obv_symbol</property>
					<property label="Obverse Type Description">obv_type</property>
					<property label="Parent Type ID" constraint="cointype">broader</property>
					<property label="Record ID">id</property>
					<property label="Reference">reference</property>
					<property label="Region URI">geo_region_uri</property>
					<property label="Replaced By ID" constraint="cointype">isReplacedBy</property>
					<property label="Replaces ID" constraint="cointype">replaces</property>
					<property label="Reverse Deity URI">rev_deity_uri</property>
					<property label="Reverse Die ID">rev_die</property>
					<property label="Reverse Legend">rev_legend</property>
					<property label="Reverse Portrait URI">rev_portrait_uri</property>
					<property label="Reverse Symbol">rev_symbol</property>
					<property label="Reverse Type Description">rev_type</property>
					<property label="Sort ID" constraint="cointype">sortId</property>
					<property label="Start Date">fromDate</property>
					<property label="Stated Authority URI">auth_statedAuthority_uri</property>
					<property label="Thickness" constraint="object">thickness</property>
					<property label="Title">title</property>
					<property label="Type Number" constraint="cointype">typeNumber</property>
					<property label="Type Series URI" constraint="cointype">typeSeries_uri</property>
					<property label="Weight" constraint="object">weight</property>
					<property label="Width" constraint="object">width</property>
				</properties>
			</xforms:instance>

			<xforms:instance id="languages">
				<xi:include href="instances/languages.xml"/>
			</xforms:instance>

			<xforms:instance id="semantic-properties" xxf:exclude-result-prefixes="#all">
				<properties xmlns="">
					<property label="SKOS Definition">skos:definition</property>
					<property label="SKOS Note">skos:note</property>
					<property label="SKOS ScopeNote">skos:scopeNote</property>
				</properties>
			</xforms:instance>

			<xforms:instance id="mappings" xxf:exclude-result-prefixes="#all">
				<mappings xmlns=""/>
			</xforms:instance>

			<xforms:instance id="validation-model" xxf:exclude-result-prefixes="#all">
				<validation xmlns=""/>
			</xforms:instance>

			<xforms:instance id="nomisma-uris" xxf:exclude-result-prefixes="#all">
				<ids xmlns=""/>
			</xforms:instance>

			<xforms:instance id="type-symbol-uris" xxf:exclude-result-prefixes="#all">
				<types xmlns=""/>
			</xforms:instance>

			<xforms:instance id="parents-valid" xxf:exclude-result-prefixes="#all">
				<ids xmlns=""/>
			</xforms:instance>

			<!-- NUDS instance for parent type -->
			<xforms:instance id="related-nuds" xxf:exclude-result-prefixes="#all">
				<nuds/>
			</xforms:instance>

			<!-- Google Spreadsheet Atom -->
			<xforms:instance id="spreadsheet-feed">
				<feed xmlns=""/>
			</xforms:instance>

			<xforms:instance id="feed" xxf:exclude-result-prefixes="#all">
				<feed xmlns=""/>
			</xforms:instance>

			<!-- Solr instances -->
			<xforms:instance id="addIndex">
				<add xmlns=""/>
			</xforms:instance>

			<xforms:instance id="sendCommit">
				<commit/>
			</xforms:instance>

			<!-- ************* BINDINGS **********************-->
			<xforms:bind nodeset="instance('control-instance')">
				<xforms:bind nodeset="type" required="true()"/>
				<xforms:bind nodeset="load-trigger" id="load-trigger" type="xs:boolean" readonly=". != true()"
					calculate="string-length(../spreadsheet-key) != 0"/>
				<xforms:bind nodeset="position" type="xs:integer"/>

				<!-- enable/disable buttons based on validation -->
				<xforms:bind nodeset="mappings-valid" type="xs:boolean"/>
				<xforms:bind nodeset="metadata-valid" type="xs:boolean"/>
				<xforms:bind nodeset="validate-trigger" id="validate-trigger" type="xs:boolean" readonly="../mappings-valid = false()"/>
				<xforms:bind nodeset="import-trigger" id="import-trigger" type="xs:boolean"/>

				<!-- additional boolean options for modeling and indexing -->
				<xforms:bind nodeset="exactMatch-reference" type="xs:boolean"/>
				<xforms:bind nodeset="link-to-coinType" type="xs:boolean"/>
				<xforms:bind nodeset="index-to-solr" type="xs:boolean" readonly="../deprecate-ids = true()"/>
				<xforms:bind nodeset="validate-ids" type="xs:boolean"/>
				<xforms:bind nodeset="deprecate-ids" type="xs:boolean"/>
			</xforms:bind>

			<!-- count(mapping[@to = 'id']) = 1 and count(mapping[@to = 'title']) &gt;= 1 and 
				(count(mapping[@to = 'fromDate']) = count(mapping[@to = 'toDate'])) and count(mapping[@to = 'fromDate']) &lt;= 1 and
				count(//mapping[@to='obv_legend']) &lt;= 1 and count(//mapping[@to='rev_legend']) &lt;= 1 and
				count(//mapping[@to='obv_die']) &lt;= 1 and count(//mapping[@to='rev_die']) &lt;= 1 and
				(if (instance('config')/collection_type = 'cointype') then count(mapping[@to = 'objectType_uri']) = 1 else if (instance('control-instance')/link-to-coinType = false()) then count(mapping[@to = 'objectType_uri']) = 1 else count(mapping[@to = 'objectType_uri']) &lt;= 1) and
				(if (instance('control-instance')/link-to-coinType = true() and instance('config')/collection_type = 'object') then count(mapping[@to = 'coinType']) = 1 else count(mapping[@to = 'coinType']) = 0)
				and count(mapping[@to = 'typeSeries_uri']) &lt;= 1 and count(mapping[@to = 'typeNumber']) &lt;= 1
				and count(mapping[@to = 'axis']) &lt;= 1 and count(mapping[@to = 'thickness']) &lt;= 1 and count(mapping[@to = 'diameter']) &lt;= 1 and count(mapping[@to = 'height']) &lt;= 1 and count(mapping[@to = 'width']) &lt;= 1 and count(mapping[@to = 'weight']) &lt;= 1
				and count(mapping[@to = 'height']) = count(mapping[@to = 'width'])
				and not(mapping[@to='diameter'] and (mapping[@to='height'] or mapping[@to='width']))" -->

			<xforms:bind nodeset="instance('mappings')"
				constraint="count(mapping[@to = 'id']) = 1 and count(mapping[@to = 'title']) &gt;= 1 and 
				(count(mapping[@to = 'fromDate']) = count(mapping[@to = 'toDate'])) and count(mapping[@to = 'fromDate']) &lt;= 1 and
				count(//mapping[@to='obv_legend']) &lt;= 1 and count(//mapping[@to='rev_legend']) &lt;= 1 and
				count(//mapping[@to='obv_die']) &lt;= 1 and count(//mapping[@to='rev_die']) &lt;= 1 and
				(if (instance('config')/collection_type = 'cointype') then count(mapping[@to = 'objectType_uri']) = 1 else if (instance('control-instance')/link-to-coinType = false()) then count(mapping[@to = 'objectType_uri']) = 1 else count(mapping[@to = 'objectType_uri']) &lt;= 1) and
				(if (instance('control-instance')/link-to-coinType = true() and instance('config')/collection_type = 'object') then count(mapping[@to = 'coinType']) = 1 else count(mapping[@to = 'coinType']) = 0)
				and count(mapping[@to = 'typeSeries_uri']) &lt;= 1 and count(mapping[@to = 'typeNumber']) &lt;= 1
				and count(mapping[@to = 'axis']) &lt;= 1 and count(mapping[@to = 'thickness']) &lt;= 1 and count(mapping[@to = 'diameter']) &lt;= 1 and count(mapping[@to = 'height']) &lt;= 1 and count(mapping[@to = 'width']) &lt;= 1 and count(mapping[@to = 'weight']) &lt;= 1
				and count(mapping[@to = 'height']) = count(mapping[@to = 'width'])
				and not(mapping[@to='diameter'] and (mapping[@to='height'] or mapping[@to='width']))">
				<!-- language bindings -->
				<xforms:bind nodeset="mapping[@to='title']">
					<xforms:bind nodeset="@lang" required="true()"
						constraint="string-length(.) &gt; 0 and count(//mapping[@to='title']/@lang) = count(distinct-values(//mapping[@to='title']/@lang))"/>
				</xforms:bind>
				<xforms:bind nodeset="mapping[@to='obv_type']">
					<xforms:bind nodeset="@lang" required="true()"
						constraint="string-length(.) &gt; 0 and count(//mapping[@to='obv_type']/@lang) = count(distinct-values(//mapping[@to='obv_type']/@lang))"
					/>
				</xforms:bind>
				<xforms:bind nodeset="mapping[@to='rev_type']">
					<xforms:bind nodeset="@lang" required="true()"
						constraint="string-length(.) &gt; 0 and count(//mapping[@to='rev_type']/@lang) = count(distinct-values(//mapping[@to='rev_type']/@lang))"
					/>
				</xforms:bind>
				<xforms:bind nodeset="mapping[@to = 'note']">
					<xforms:bind nodeset="@lang" required="true()"/>
					<xforms:bind nodeset="@property" required="true()"/>
				</xforms:bind>

				<!-- measurements -->
				<xforms:bind nodeset="mapping[@to='height']" constraint="count(//mapping[@to='width']) = 1 and count(//mapping[@to='diameter']) = 0"/>
				<xforms:bind nodeset="mapping[@to='width']" constraint="count(./mapping[@to='height']) = 1 and count(//mapping[@to='diameter']) = 0"/>
				<xforms:bind nodeset="mapping[@to='diameter']" constraint="count(//mapping[@to='height']) = 0 and count(//mapping[@to='width']) = 0"/>
			</xforms:bind>

			<xforms:bind nodeset="instance('nomisma-uris')">
				<xforms:bind nodeset="id" type="xs:boolean"/>
			</xforms:bind>

			<!-- **************** DYNAMIC VALIDATION CONTROLS ********************** -->
			<!-- ensure that the mappings are valid before continuing with validation -->
			<xforms:action ev:event="xxforms-invalid" ev:observer="mappings">
				<xforms:setvalue ref="instance('control-instance')/mappings-valid" value="false()"/>
			</xforms:action>

			<xforms:action ev:event="xxforms-valid" ev:observer="mappings">
				<xforms:setvalue ref="instance('control-instance')/mappings-valid" value="true()"/>
			</xforms:action>

			<!-- **************** CUSTOM DATATYPES ********************** -->
			<!-- URL validation. Example from http://stackoverflow.com/questions/3381507/xml-validation-validating-a-uri-type -->
			<xs:schema elementFormDefault="qualified" attributeFormDefault="unqualified">
				<xs:simpleType name="custom.httpURL">
					<xs:restriction base="xs:anyURI">
						<!-- accepts only http:// or https:// URIs. -->
						<xs:pattern value="https?://.+"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:schema>

			<!-- ************* SUBMISSIONS **********************-->
			<!-- ************* GOOGLE DRIVE **********************-->
			<xforms:submission id="get-sheets-api" serialization="none" method="get" action="{instance('control-instance')/sheets-api-url}" instance="feed"
				replace="instance">
				<xforms:message ev:event="xforms-submit-error" level="modal">Unable to receive Atom from Google Drive for the worksheet ID.</xforms:message>
				<!-- if a feed is successfully received, set the id for the workshop -->
				<xforms:action ev:event="xforms-submit-done">
					<!--<xforms:action if="count(instance('feed')//atom:entry) &gt; 0">
						<!-\- read whether or not the spreadsheet already exists in the system -\->
						<xforms:action if="not(instance('spreadsheet-rdf')/prov:Entity[@rdf:about = instance('control-instance')/spreadsheet-uri])">
							<!-\- if there is no matching URI for the spreadsheet (prov:Entity), then insert the spreadsheet template into the spreadsheet RDF -\->
							<xforms:insert context="instance('spreadsheet-rdf')" nodeset="./child::node()[last()]" origin="instance('spreadsheet-template')"/>
							<xforms:setvalue ref="instance('spreadsheet-rdf')/prov:Entity[last()]/@rdf:about"
								value="instance('control-instance')/spreadsheet-uri"/>
						</xforms:action>

						
					</xforms:action>-->
					<!-- if there are no entries in the Atom feed, set the error interface -->
				</xforms:action>
			</xforms:submission>

			<!-- ***** LOADING COLLECTIONS/CONFIG *****-->
			<xforms:submission id="load-config" serialization="none" method="get"
				action="{instance('exist-config')/url}{instance('control-instance')/collection-name}/config.xml"
				xxf:username="{instance('exist-config')/username}" xxf:password="{instance('exist-config')/password}" replace="instance"
				instance="config">
				<xforms:message ev:event="xforms-submit-error" level="modal">Unable to load Numishare configuration</xforms:message>

				<xforms:action ev:event="xforms-submit-done">
					<xforms:setvalue ref="instance('nuds')/@recordType"
						value="if (instance('config')/collection_type = 'cointype') then 'conceptual' else 'physical'"/>
				</xforms:action>
			</xforms:submission>

			<xforms:submission id="load-collections" serialization="none" method="get" action="{instance('exist-config')/url}collections-list.xml"
				replace="instance" instance="collections-list" xxf:username="{instance('exist-config')/username}"
				xxf:password="{instance('exist-config')/password}">
				<!-- if the config loads successfully, set the collection names based on authentication -->
				<xforms:action ev:event="xforms-submit-done">
					<!-- by default set the collection-name from the security role -->
					<xforms:action if="not(xxf:is-user-in-role('numishare-admin'))">
						<xforms:action if="string(instance('collections-list')/collection[@role=instance('control-instance')/request-security/role]/@name)">
							<xforms:setvalue ref="instance('control-instance')/collection-name"
								value="instance('collections-list')/collection[@role=instance('control-instance')/request-security/role]/@name"/>
							<xforms:send submission="load-config"/>
						</xforms:action>
					</xforms:action>
				</xforms:action>
				<!-- if the config has not been created (given that the URL in ../exist-config.xml is correct), create it -->
				<xforms:message ev:event="xforms-submit-error" level="modal">Unable to load Numishare collections list.</xforms:message>
			</xforms:submission>

			<!-- ************************* LOAD NOMISMA RDF/XML ************************** -->
			<xforms:submission id="load-rdf" serialization="none" method="get"
				action="{instance('control-instance')/rdf-api}?identifiers={instance('control-instance')/identifiers}" replace="instance" instance="rdf-concept">
				<!-- if there's an error, report the error into the Nomisma ID instance -->
				<xforms:action ev:event="xforms-submit-error">
					<xforms:message level="modal">
						<xforms:output value="concat('Unable to access ', instance('control-instance')/rdf-api)"/>
					</xforms:message>
				</xforms:action>
				<!-- otherwise, validate the URI and insert the skos:Concept into the aggregate instance('rdf') -->
				<xforms:action ev:event="xforms-submit-done">
					<!-- perform validation for any Concept URI that does not exist within the rdf response -->
					<!-- apply for Nomisma -->
					<xforms:action if="contains(instance('control-instance')/rdf-api, 'nomisma.org')">
						<xforms:action xxf:iterate="instance('nomisma-uris')/id">
							<xforms:setvalue if="instance('rdf-concept')/*[@rdf:about = context()/@uri]" ref="context()" value="true()"/>
						</xforms:action>
					</xforms:action>

					<!-- apply for Numismatics.org type series -->
					<xforms:action if="contains(instance('control-instance')/rdf-api, 'numismatics.org')">
						<xforms:var name="series" select="substring-before(instance('control-instance')/rdf-api, 'apis')"/>
						<xforms:action xxf:iterate="instance('type-symbol-uris')/series[@uri = $series]/id">
							<xforms:setvalue if="instance('rdf-concept')/*[@rdf:about = context()/@uri]" ref="context()" value="true()"/>
						</xforms:action>
					</xforms:action>

					<!-- insert the Concept RDF (whether types or Nomisma) from the API response RDF into the primary RDF instance -->
					<xforms:insert context="instance('rdf')" nodeset="./child::node()[last()]"
						origin="instance('rdf-concept')/*[rdf:type/@rdf:resource = 'http://www.w3.org/2004/02/skos/core#Concept']"/>
				</xforms:action>
			</xforms:submission>

			<!-- ************************* LOAD PARENT NUDS FILE ************************** -->
			<xforms:submission id="load-nuds" serialization="none" method="get"
				action="{instance('exist-config')/url}{instance('control-instance')/collection-name}/objects/{encode-for-uri(instance('control-instance')/target-id)}.xml"
				xxf:username="{instance('exist-config')/username}" xxf:password="{instance('exist-config')/password}" replace="instance"
				instance="related-nuds">

				<!-- evaluate whether the NUDS document exists in the exist-db collection -->
				<xforms:action ev:event="xforms-submit-done">
					<xforms:insert context="instance('parents-valid')" nodeset="./child::node()[last()]"
						origin="xforms:element('id', data(instance('control-instance')/target-id))"/>
				</xforms:action>
				<xforms:action ev:event="xforms-submit-error">
					<xforms:insert context="instance('validation-model')/record[last()]" nodeset="./child::node()[last()]"
						origin="xforms:element('error', concat('ID not found in spreadsheet or Numishare XML collection for ', instance('properties')/property[. = instance('control-instance')/mapping]/@label))"
					/>
				</xforms:action>
			</xforms:submission>

			<xforms:submission id="save-nuds" ref="instance('nuds')" xxf:username="{instance('exist-config')/username}"
				xxf:password="{instance('exist-config')/password}"
				action="{instance('exist-config')/url}{instance('control-instance')/collection-name}/objects/{instance('nuds')/nuds:control/nuds:recordId}.xml"
				method="put" replace="none">
				<xforms:message ev:event="xforms-submit-error" level="modal">Error saving file to eXist-db collection.</xforms:message>


				<xforms:action ev:event="xforms-submit-done">
					<xforms:setvalue ref="instance('control-instance')/status"
						value="concat(instance('nuds')/nuds:control/nuds:recordId, ' saved to eXist-db collection.')"/>

					<!-- if the record is approved or approved subtype, add it to the identifier list for indexing, if activated -->
					<xforms:action if="instance('control-instance')/index-to-solr = true()">
						<xforms:var name="publicationStatus" select="instance('nuds')/nuds:control/nuds:publicationStatus"/>

						<!-- only index active types and subtypes -->
						<xforms:action if="$publicationStatus = 'approved' or $publicationStatus = 'approvedSubtype'">
							<!-- set position -->
							<xforms:setvalue ref="instance('control-instance')/position" value="instance('control-instance')/position + 1"/>

							<!-- set proper separator based on position. IDs are to be indexed in blocks of 100 -->
							<xforms:var name="sep"
								select="if (instance('control-instance')/position = 1) then '' else if (instance('control-instance')/position mod 100 = 0) then ',' else '|'"/>
							<xforms:var name="recordId" select="instance('nuds')/nuds:control/nuds:recordId"/>

							<xforms:setvalue ref="instance('control-instance')/identifiers"
								value="concat(instance('control-instance')/identifiers, $sep, $recordId)"/>
						</xforms:action>
					</xforms:action>
				</xforms:action>
			</xforms:submission>

			<!-- ************************* SOLR SUBMISSIONS ************************** -->
			<!-- pass identifiers URL parameter to xquery process in Cocoon to generate large Solr add document -->
			<xforms:submission id="generate-add-document" method="get" replace="instance" instance="addIndex" serialization="none"
				resource="/numishare/{instance('control-instance')/collection-name}/ingest?identifiers={instance('control-instance')/identifiers}">
				<xforms:message ev:event="xforms-submit-error" level="modal">Error getting Solr document from XQuery ingestion pipeline.</xforms:message>
				<xforms:action ev:event="xforms-submit-done">
					<xforms:send submission="post-solr-doc"/>
				</xforms:action>
			</xforms:submission>

			<!-- post instance to Solr -->
			<xforms:submission id="post-solr-doc" action="{instance('config')/solr_published}update" ref="instance('addIndex')" instance="addIndex"
				replace="instance" method="post">
				<xforms:message ev:event="xforms-submit-error" level="modal">Data Failed to POST to Solr. Index may be offline or URL is
					incorrect.</xforms:message>
				<xforms:action ev:event="xforms-submit-done">
					<xforms:setvalue ref="instance('control-instance')/status">Successfully published to Solr.</xforms:setvalue>
					<xforms:send submission="submit-commit"/>
				</xforms:action>
			</xforms:submission>

			<!-- send commit -->
			<xforms:submission id="submit-commit" action="{instance('config')/solr_published}update" ref="instance('sendCommit')" instance="sendCommit"
				replace="none" method="post">
				<xforms:message level="modal" ev:event="xforms-submit-error">Failed to commit to Solr index.</xforms:message>
			</xforms:submission>

			<!-- ********** XFORMS-MODEL-CONSTRUCT-DONE ********** -->
			<xforms:action ev:event="xforms-model-construct-done">
				<!-- set username -->
				<xforms:setvalue ref="instance('control-instance')/username" value="xxf:get-remote-user()"/>

				<!-- if there's a collection-name session attribute carried over from numishare-admin, then use it to set the collection-name -->
				<xforms:action if="string(xxf:get-session-attribute('collection-name'))">
					<xforms:setvalue ref="instance('control-instance')/collection-name" value="xxf:get-session-attribute('collection-name')"/>
					<xforms:send submission="load-config"/>
				</xforms:action>

				<xforms:action if="not(string(xxf:get-session-attribute('collection-name')))">
					<xforms:insert context="instance('control-instance')" nodeset="collection-name" position="after"
						origin="xxf:call-xpl('oxf:/apps/numishare/xpl/get-authentication.xpl', 'dump', instance('dump'), 'data')"/>
					<xforms:send submission="load-collections"/>
				</xforms:action>

				<!-- iterate through the available symbol positions in the config in order to populate the property list -->
				<xforms:action
					xxf:iterate="xxf:sort(instance('config')/positions/position, label[@lang = instance('control-instance')/language], 'text', 'ascending')">
					<xforms:var name="side" select="context()/@side"/>
					<xforms:var name="position" select="context()/@value"/>
					<xforms:var name="label" select="context()/label[@lang = instance('control-instance')/language]"/>

					<xforms:action if="$side = 'obv'">
						<xforms:insert context="instance('properties')" nodeset="property[starts-with(@label, 'Obverse Symbol')][last()]" position="after"
							origin="xforms:element('property', (xforms:attribute('label', concat('Obverse Symbol: ', $label)), concat($side, '_', $position, '_symbol')))"
						/>
					</xforms:action>
					<xforms:action if="$side = 'rev'">
						<xforms:insert context="instance('properties')" nodeset="property[starts-with(@label, 'Reverse Symbol')][last()]" position="after"
							origin="xforms:element('property', (xforms:attribute('label', concat('Reverse Symbol: ', $label)), concat($side, '_', $position, '_symbol')))"
						/>
					</xforms:action>
					<xforms:action if="$side = 'both'">
						<xforms:insert context="instance('properties')" nodeset="property[starts-with(@label, 'Obverse Symbol')][last()]" position="after"
							origin="xforms:element('property', (xforms:attribute('label', concat('Obverse Symbol: ', $label)), concat('obv_', $position, '_symbol')))"/>
						<xforms:insert context="instance('properties')" nodeset="property[starts-with(@label, 'Reverse Symbol')][last()]" position="after"
							origin="xforms:element('property', (xforms:attribute('label', concat('Reverse Symbol: ', $label)), concat('rev_', $position, '_symbol')))"
						/>
					</xforms:action>
				</xforms:action>
			</xforms:action>

			<!-- ********** XFORMS-READY ********** -->
			<!--<xforms:action ev:event="xforms-ready">
				<!-\- test spreadsheet RDF validity on xforms-ready -\->
				<xforms:setvalue ref="instance('control-instance')/metadata-valid" value="true()" if="xxf:valid(instance('spreadsheet-rdf'), true())"/>
			</xforms:action>-->
		</xforms:model>
	</head>

	<body>
		<xforms:var name="display_path">../</xforms:var>
		<div class="container-fluid">
			<div class="row">
				<div class="col-md-3 pull-right text-right">
					<h4>
						<a href="logout"><span class="glyphicon glyphicon-log-out"></span> logout</a>
					</h4>
				</div>
			</div>
			<div class="row">
				<div class="col-md-12">
					<p><a href="../"><span class="glyphicon glyphicon-arrow-left"></span>Return to Admin</a></p>
					<xforms:group ref=".[string-length(instance('control-instance')/status) &gt; 0]">
						<div class="alert-success alert-box alert">
							<span class="glyphicon glyphicon-info-sign"></span>
							<strong>Status:</strong>
							<xforms:output ref="instance('control-instance')/status"/>
						</div>
					</xforms:group>
					<h1>Import Records into Numishare</h1>
					<xforms:switch>
						<xforms:case id="default">
							<p>This interface will import records from a Google Spreadsheet into Numishare. The type of record must conform to the specimen/coin
								type collection setting established in the Numishare config. Prior to the display of the column mapping interface, this workflow
								will parse and validate the Nomisma URIs that exist in the spreadsheet.</p>

							<xforms:group ref="instance('control-instance')">
								<div class="subsection">
									<div>
										<xforms:output ref="instance('config')/collection_type">
											<xforms:label>Collection Type</xforms:label>
										</xforms:output>
									</div>
									<div>
										<xforms:select1 ref="language">
											<xforms:label>Record Language</xforms:label>
											<xforms:itemset nodeset="instance('languages')/language">
												<xforms:label ref="."/>
												<xforms:value ref="@value"/>
											</xforms:itemset>
										</xforms:select1>
									</div>
									<div>
										<xforms:input ref="spreadsheet-key">
											<xforms:label>Spreadsheet ID</xforms:label>
										</xforms:input>
										<xforms:trigger bind="load-trigger">
											<xforms:label>Load Spreadsheet</xforms:label>
											<!-- load the spreadsheet and write the column mappings instance -->
											<xforms:action ev:event="DOMActivate">
												<xforms:setvalue ref="instance('control-instance')/sheets-api-url"
													value="concat('https://spreadsheets.google.com/feeds/worksheets/', instance('control-instance')/spreadsheet-key, '/public/full')"/>
												<xforms:setvalue ref="instance('control-instance')/sheets-api-action">read-sheets</xforms:setvalue>
												<xforms:send submission="get-sheets-api"/>

												<xforms:action ev:event="xforms-submit-done">
													<!-- get the worksheet ID and call the Google Sheets API in order to read the column headings for the mapping interface -->
													<xforms:setvalue ref="instance('control-instance')/spreadsheet-uri"
														value="concat('https://docs.google.com/spreadsheets/d/', instance('control-instance')/spreadsheet-key, '/pubhtml')"/>
													<xforms:setvalue ref="instance('control-instance')/worksheet_id"
														value="tokenize(instance('feed')//atom:entry[1]/atom:id, '/')[last()]"/>
													<xforms:setvalue ref="instance('control-instance')/sheets-api-url"
														value="concat('https://spreadsheets.google.com/feeds/list/', instance('control-instance')/spreadsheet-key, '/', instance('control-instance')/worksheet_id, '/public/basic')"/>

													<xforms:setvalue ref="instance('control-instance')/sheets-api-action">populate-mappings</xforms:setvalue>
													<xforms:send submission="get-sheets-api"/>

													<!-- load the basic sheet and read the URI of the first entry in order to prepare the column mappings -->
													<xforms:action ev:event="xforms-submit-done">
														<!-- if there are no entries, then toggle the error interface -->
														<xforms:action if="count(instance('feed')//atom:entry) = 0">
															<xforms:toggle case="mapping-error-interface"/>
														</xforms:action>

														<xforms:action if="count(instance('feed')//atom:entry) &gt; 0">
															<!-- get the full model for the first row in the sheet -->
															<xforms:setvalue ref="instance('control-instance')/sheets-api-url"
																value="replace(instance('feed')//atom:entry[1]/atom:id, '/basic/', '/full/')"/>
															<xforms:send submission="get-sheets-api"/>


															<xforms:action ev:event="xforms-submit-done">
																<xforms:action
																	xxf:iterate="instance('feed')/*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended']">
																	<xforms:var name="heading" select="name()"/>
																	<xforms:insert context="instance('mappings')" nodeset="./child::node()[last()]"
																		origin="xforms:element('mapping', (xforms:attribute('from', $heading), xforms:attribute('to', '')))"
																	/>
																</xforms:action>

																<!-- toggle to the mapping interface -->
																<xforms:toggle case="mapping-interface"/>
															</xforms:action>
														</xforms:action>
													</xforms:action>
												</xforms:action>
											</xforms:action>
										</xforms:trigger>
									</div>
								</div>


								<div class="subsection">
									<h3>Other Options</h3>
									<table class="table">

										<tbody>
											<tr>
												<td><xforms:input ref="index-to-solr"/></td>
												<td>Index records in Solr for search/browse after spreadsheet processing is completed.</td>
											</tr>
											<xforms:group ref=".[instance('config')/collection_type = 'cointype']">
												<tr>
													<td><xforms:input ref="exactMatch-reference"/></td>
													<td>Convert Exact Match coin type URIs to human-readable references (with a link to the URI).</td>
												</tr>
												<tr>
													<td>
														<xforms:input ref="validate-ids"/>
													</td>
													<td><strong>Validate IDs</strong>
														<i>Recommended</i>: Record ID numbers for parent (skos:broader) or deprecation-related coin types
														(dcterms:replaces or dcterms:isReplacedBy) will be validated in order to ensure their presence either in
														this spreadsheet or the eXist-db XML collection. Disabling this feature is sometimes useful for
														publishing deprecated type corpora that contain concordances to new editions that have not been uploaded
														yet. Note that automatic HTTP 303 (See Other) forwarding may result in errors for mistyped IDs or IDs
														that do not exist in Numishare yet.</td>
												</tr>
												<tr>
													<td>
														<xforms:input ref="deprecate-ids">
															<!-- when the box is checked, change value of index-to-solr -->
															<xforms:action ev:event="xforms-value-changed">
																<xforms:setvalue ref="../index-to-solr" value="false()" if=". = true()"/>
																<xforms:setvalue ref="../index-to-solr" value="true()" if=". = false()"/>
															</xforms:action>
														</xforms:input>
													</td>
													<td><strong>Deprecate IDs</strong>: enable this to deprecate all IDs by default. This option should be
														enabled when publishing old type corpora or editions before publishing a new corpus to the same
														collection (e.g., to publish Svoronos 1904 types before publishing Coins of the Ptolemaic Empire IDs).
														Deprecated IDs are not indexed into Solr for the search/browse interfaces.</td>
												</tr>
											</xforms:group>
											<xforms:group ref=".[instance('config')/collection_type = 'object']">
												<tr>
													<td><xforms:input ref="link-to-coinType"/></td>
													<td>Link the Typological Description directly to the coin type URI (when applicable) so that Numishare will
														import typological data from this URI in real-time. Note that physical objects not linked to a coin type
														URI require an Object Type URI as a fundamental requirement in the <code>&lt;typeDesc&gt;</code>.</td>
												</tr>
											</xforms:group>
										</tbody>
									</table>
								</div>


							</xforms:group>
						</xforms:case>
						<xforms:case id="nomisma-validation">
							<div class="section">

								<div class="alert-danger alert-box alert">
									<span class="glyphicon glyphicon-exclamation-sign"></span>
									<strong>Alert:</strong> URI validation error(s).</div>

								<h3>URI Validation</h3>

								<xforms:group ref=".[instance('nomisma-uris')/id = false()]">
									<div>
										<h4>Nomisma.org Validation</h4>
										<p>The following URIs do not presently exist in Nomisma.org:</p>

										<xforms:group ref="instance('nomisma-uris')">
											<ol>
												<xforms:repeat nodeset="id[. = false()]">
													<li>
														<xforms:output ref="@uri"/>
													</li>
												</xforms:repeat>
											</ol>
										</xforms:group>
									</div>
								</xforms:group>

								<!-- display list of errors for each type series -->
								<xforms:repeat nodeset="instance('type-symbol-uris')/series[id = false()]">
									<div>
										<h4>Type Series <xforms:output ref="@uri"/> Validation</h4>
										<p>The following Coin Type URIs do not exist within the target digital corpus:</p>

										<ol>
											<xforms:repeat nodeset="id[. = false()]">
												<li>
													<xforms:output ref="@uri"/>
												</li>
											</xforms:repeat>
										</ol>
									</div>
								</xforms:repeat>
								<p>Please either update the source spreadsheet to fix errors or submit these concepts for creation in Nomisma.org before
									continuing with the spreadsheet import.</p>
							</div>
						</xforms:case>
						<xforms:case id="mapping-interface">
							<!--<xforms:group ref="instance('spreadsheet-rdf')/prov:Entity[@rdf:about  =instance('control-instance')/spreadsheet-uri]">
								<div class="section">
									<h3>Spreadsheet Metadata</h3>
									<div class="trigger_container">
										<xforms:trigger appearance="minimal">
											<xforms:label>
												<span class="glyphicon glyphicon-plus"></span>Contributor</xforms:label>
											<xforms:insert ev:event="DOMActivate" context="." nodeset="./child::node()[last()]"
												origin="xforms:element('dcterms:contributor', (xforms:attribute('rdf:resource'), ''))"/>
										</xforms:trigger>
									</div>
									<xforms:group ref=".[dcterms:creator/@rdf:resource = dcterms:contributor/@rdf:resource]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> The same person cannot be a creator and contributor simultaneously.</div>
									</xforms:group>
									<xforms:group
										ref=".[count(dcterms:contributor/@rdf:resource) &gt; count(distinct-values(dcterms:contributor/@rdf:resource))]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> The same contributor is selected more than once.</div>
									</xforms:group>
									<xforms:group ref="dcterms:description">
										<div>
											<xforms:textarea ref=".">
												<xforms:label>Description</xforms:label>
												<xforms:alert>Required</xforms:alert>
											</xforms:textarea>
											<xforms:select1 ref="@xml:lang">
												<xforms:item>
													<xforms:label>Select...</xforms:label>
													<xforms:value/>
												</xforms:item>
												<xforms:itemset nodeset="instance('languages')/language">
													<xforms:label ref="."/>
													<xforms:value ref="@value"/>
												</xforms:itemset>
												<xforms:alert>Required</xforms:alert>
											</xforms:select1>
										</div>
									</xforms:group>
									<div>
										<xforms:select1 ref="dcterms:creator/@rdf:resource">
											<xforms:label>Primary Creator</xforms:label>
											<xforms:alert>Required</xforms:alert>
											<xforms:item>
												<xforms:label>Select...</xforms:label>
												<xforms:value/>
											</xforms:item>
											<xforms:itemset nodeset="instance('editor-list')/item">
												<xforms:label ref="."/>
												<xforms:value ref="@uri"/>
											</xforms:itemset>
										</xforms:select1>
									</div>
									<xforms:repeat nodeset="dcterms:contributor">
										<div>
											<xforms:select1 ref="@rdf:resource">
												<xforms:label>Contributor</xforms:label>
												<xforms:alert>Required</xforms:alert>
												<xforms:item>
													<xforms:label>Select...</xforms:label>
													<xforms:value/>
												</xforms:item>
												<xforms:itemset nodeset="instance('editor-list')/item">
													<xforms:label ref="."/>
													<xforms:value ref="@uri"/>
												</xforms:itemset>
											</xforms:select1>
											<xforms:trigger appearance="minimal">
												<xforms:delete ev:event="DOMActivate" context="."/>
												<xforms:label>
													<span class="glyphicon glyphicon-remove"></span>
												</xforms:label>
											</xforms:trigger>
										</div>
									</xforms:repeat>
								</div>
							</xforms:group>-->
							<div class="section">
								<h3>Mapping</h3>
								<p>Associate the headings with allowable properties, where applicable. Note that the NUDS Record ID and Title are required.</p>

								<xforms:group ref="instance('mappings')">
									<!-- required elements -->
									<xforms:group ref=".[count(mapping[@to='id']) != 1]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong>There must be one Record ID.</div>
									</xforms:group>
									<xforms:group ref=".[count(mapping[@to='title']) = 0]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> A title is required.</div>
									</xforms:group>
									<xforms:group ref=".[instance('config')/collection_type = 'cointype' and count(mapping[@to = 'objectType_uri']) != 1]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There must be one Object Type defined for a Coin Type record.</div>
									</xforms:group>
									<xforms:group
										ref=".[instance('config')/collection_type = 'object' and instance('control-instance')/link-to-coinType = false() and count(mapping[@to = 'objectType_uri']) != 1]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There must be one Object Type defined for physical objects not directly linked to a Coin
											Type URI.</div>
									</xforms:group>

									<!-- language warnings -->
									<xforms:group ref=".[count(mapping[@to='title']/@lang) != count(distinct-values(mapping[@to='title']/@lang))]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> Title languages must be unique.</div>
									</xforms:group>
									<xforms:group ref=".[count(mapping[@to='obv_type']/@lang) != count(distinct-values(mapping[@to='obv_type']/@lang))]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> Obverse type description languages must be unique.</div>
									</xforms:group>
									<xforms:group ref=".[count(mapping[@to='rev_type']/@lang) != count(distinct-values(mapping[@to='rev_type']/@lang))]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> Reverse type description languages must be unique.</div>
									</xforms:group>

									<!-- dates -->
									<xforms:group
										ref=".[count(mapping[@to='fromDate']) &gt; 1 and count(mapping[@to='toDate']) &gt; 1 or count(mapping[@to='fromDate']) != count(mapping[@to='toDate'])]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There must be both a Start Date and End Date, with a maximum of 1 mapping each.</div>
									</xforms:group>

									<!-- other -->
									<xforms:group ref=".[count(mapping[@to='obv_legend']) != count(distinct-values(mapping[@to='obv_legend']))]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There can only be one Obverse Legend.</div>
									</xforms:group>
									<xforms:group ref=".[count(mapping[@to='rev_legend']) != count(distinct-values(mapping[@to='rev_legend']))]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There can only be one Reverse Legend.</div>
									</xforms:group>

									<xforms:group ref=".[count(mapping[@to='obv_die']) != count(distinct-values(mapping[@to='obv_die']))]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There can only be one Obverse Die ID.</div>
									</xforms:group>
									<xforms:group ref=".[count(mapping[@to='rev_die']) != count(distinct-values(mapping[@to='rev_die']))]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There can only be one Reverse Die ID.</div>
									</xforms:group>

									<xforms:group
										ref=".[instance('control-instance')/link-to-coinType = true() and instance('config')/collection_type = 'object' and count(mapping[@to = 'coinType']) != 1]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There must be one column mapped to Coin Type URI.</div>
									</xforms:group>
									<xforms:group
										ref=".[instance('control-instance')/link-to-coinType = false() and instance('config')/collection_type = 'object' and count(mapping[@to = 'coinType']) &gt;= 1]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Note:</strong> Coin Type URIs that are not linked to the Typological Description should be designated as a
											Reference instead</div>
									</xforms:group>
									<xforms:group ref=".[count(mapping[@to = 'typeSeries_uri']) &gt; 1]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There must not be more than one Type Series URI.</div>
									</xforms:group>
									<xforms:group ref=".[count(mapping[@to = 'typeNumber']) &gt; 1]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There must not be more than one Type Number.</div>
									</xforms:group>

									<!-- measurements -->
									<xforms:group ref=".[count(mapping[@to = 'axis']) &gt; 1]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There must not be more than one Die Axis.</div>
									</xforms:group>

									<xforms:group
										ref=".[count(mapping[@to = 'diameter']) &gt; 1 or (count(mapping[@to = 'diameter']) &gt;= 1 and (count(mapping[@to = 'height']) &gt; 0 or count(mapping[@to = 'width']) &gt; 0))]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There must not be more than one Diameter and Diameter cannot be used in conjunction with
											Height or Width.</div>
									</xforms:group>

									<xforms:group
										ref=".[not(count(mapping[@to = 'height']) = count(mapping[@to = 'width'])) or count(mapping[@to = 'height']) &gt; 1]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There must be one Height and one Width.</div>
									</xforms:group>

									<xforms:group ref=".[count(mapping[@to = 'thickness']) &gt; 1]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There must not be more than one Thickness (Depth) measurement.</div>
									</xforms:group>

									<xforms:group ref=".[count(mapping[@to = 'weight']) &gt; 1]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> There must not be more than one Weight measurement.</div>
									</xforms:group>

									<table class="table">
										<thead>
											<tr>
												<th style="width:25%">Column Heading</th>
												<th>Property Mapping</th>
											</tr>
										</thead>
										<xforms:repeat nodeset="mapping">

											<tr>
												<td>
													<xforms:output ref="substring-after(@from, ':')"/>
												</td>
												<td>
													<xforms:select1 ref="@to">
														<xforms:alert>Mapping Error</xforms:alert>
														<xforms:item>
															<xforms:label>Select...</xforms:label>
															<xforms:value/>
														</xforms:item>
														<xforms:itemset
															nodeset="instance('properties')/property[not(@constraint) or @constraint = instance('config')/collection_type]">
															<xforms:label ref="@label"/>
															<xforms:value ref="."/>
														</xforms:itemset>
														<xforms:action ev:event="xforms-value-changed">
															<xforms:var name="property" select="."/>
															<!-- if it is a literal-based property, insert the @lang attribute -->
															<xforms:action if="$property = 'title' or $property = 'note' or ends-with($property, '_type')">
																<xforms:insert context="parent::node()" origin="xforms:attribute('lang', '')"/>
															</xforms:action>
															<!-- if it is not a literal, then delete @lang -->
															<xforms:action
																if="not($property = 'title') and not($property = 'note') and not(ends-with($property, '_type'))">
																<xforms:delete context="parent::node()" nodeset="@lang"/>
															</xforms:action>
															<!-- delete @proprety if not a note -->
															<xforms:delete context="parent::node()" nodeset="@property" if="not($property = 'note')"/>
														</xforms:action>
													</xforms:select1>
													<xforms:group ref="@lang">
														<xforms:select1 ref=".">
															<xforms:alert>Mapping Error</xforms:alert>
															<xforms:item>
																<xforms:label>Select...</xforms:label>
																<xforms:value/>
															</xforms:item>
															<xforms:itemset nodeset="instance('languages')/language">
																<xforms:label ref="."/>
																<xforms:value ref="@value"/>
															</xforms:itemset>
														</xforms:select1>
													</xforms:group>
													<!-- allow SKOS properties for coin types -->
													<xforms:group ref=".[@to = 'note' and instance('config')/collection_type = 'cointype']">
														<xforms:group ref="@property">
															<xforms:select1 ref=".">
																<xforms:alert>Required</xforms:alert>
																<xforms:item>
																	<xforms:label>Select...</xforms:label>
																	<xforms:value/>
																</xforms:item>
																<xforms:itemset nodeset="instance('semantic-properties')/property">
																	<xforms:label ref="@label"/>
																	<xforms:value ref="."/>
																</xforms:itemset>
															</xforms:select1>
															<xforms:trigger appearance="minimal">
																<xforms:label>
																	<span class="glyphicon glyphicon-remove"></span></xforms:label>
																<xforms:delete ev:event="DOMActivate" nodeset="."/>
															</xforms:trigger>
														</xforms:group>
														<xforms:group ref=".[not(@property)]">
															<xforms:trigger appearance="minimal">
																<xforms:label>
																	<span class="glyphicon glyphicon-plus"></span>Semantic Property</xforms:label>
																<xforms:insert ev:event="DOMActivate" context="." origin="xforms:attribute('property')"/>
															</xforms:trigger>
														</xforms:group>
													</xforms:group>
												</td>
											</tr>
										</xforms:repeat>
									</table>
									<xforms:trigger bind="validate-trigger">
										<xforms:label>Validate Spreadsheet</xforms:label>
										<xforms:action ev:event="DOMActivate">
											<!-- load the full feed -->
											<xforms:setvalue ref="instance('control-instance')/sheets-api-url"
												value="concat('https://spreadsheets.google.com/feeds/list/', instance('control-instance')/spreadsheet-key, '/', instance('control-instance')/worksheet_id, '/public/full')"/>
											<xforms:send submission="get-sheets-api"/>

											<!-- ********** NOMISMA/NUMISMATICS.ORG uri VALIDATION ********* -->

											<!-- evaluate Nomisma and Numismatics.org URIs first. If they are all valid, then proceed to data validation. If the URIs are invalid, 
												toggle the interface -->
											<xforms:action ev:event="xforms-submit-done">
												<!-- iterate through all of the distinct values of Nomisma URIs -->
												<xforms:action
													xxf:iterate="distinct-values(instance('feed')//*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended'][contains(., 'http://nomisma.org/') or contains(., 'http://numismatics.org/')])">
													<!-- ensure that the URI is not re-inserted due to trailing question mark for uncertainty -->
													<xforms:var name="value"
														select="if (contains(normalize-space(context()), '|')) then substring-before(normalize-space(context()), '|') else normalize-space(context())"/>
													<xforms:var name="uri" select="if (ends-with($value, '?')) then substring-before($value, '?') else $value"/>

													<!-- always validate and get RDF from Nomisma -->
													<xforms:action if="starts-with($uri, 'http://nomisma.org/')">
														<xforms:insert if="not(instance('nomisma-uris')/id[@uri = $uri])" context="instance('nomisma-uris')"
															nodeset="./child::node()[last()]"
															origin="xforms:element('id', (xforms:attribute('uri', $uri), false()))"/>
													</xforms:action>

													<!-- only validate and get numismatics.org coin type data in certain circumstances  -->
													<xforms:action if="starts-with($uri, 'http://numismatics.org/')">
														<!-- references and coin types should be validated for physical specimens, and so should Exact Match URIs 
									if these should be converted into human-readable references -->
														<xforms:action
															if="instance('config')/collection_type = 'object' or 
															(instance('config')/collection_type = 'cointype' and instance('control-instance')/exactMatch-reference = true())">
															<xforms:var name="series" select="concat('http://numismatics.org/', tokenize($uri, '/')[4], '/')"/>

															<xforms:action if="not(instance('type-symbol-uris')/series[@uri = $series]/id[@uri = $uri])">
																<!-- insert series element if not already present -->
																<xforms:insert if="not(instance('type-symbol-uris')/series[@uri = $series])"
																	context="instance('type-symbol-uris')" nodeset="./child::node()[last()]"
																	origin="xforms:element('series', xforms:attribute('uri', $series))"/>

																<xforms:insert context="instance('type-symbol-uris')/series[@uri = $series]"
																	nodeset="./child::node()[last()]"
																	origin="xforms:element('id', (xforms:attribute('uri', $uri), false()))"/>
															</xforms:action>
														</xforms:action>
													</xforms:action>
												</xforms:action>

												<!-- initiate getRDF API call for Nomisma URIs -->
												<xforms:action if="count(instance('nomisma-uris')/id) &gt; 0">
													<xforms:setvalue ref="instance('control-instance')/rdf-api">http://nomisma.org/apis/getRdf</xforms:setvalue>
													<xforms:setvalue ref="instance('control-instance')/identifiers"
														value="string-join(instance('nomisma-uris')/id/substring-after(@uri, 'id/'), '|')"/>
													<xforms:send submission="load-rdf"/>
												</xforms:action>

												<!-- initiate getRDF API call for each individual type series -->
												<xforms:action if="count(instance('type-symbol-uris')//id) &gt; 0">
													<xforms:action xxf:iterate="instance('type-symbol-uris')/series">
														<xforms:var name="series" select="context()/@uri"/>

														<!-- reset identifiers, position -->
														<xforms:setvalue ref="instance('control-instance')/identifiers"/>
														<xforms:setvalue ref="instance('control-instance')/position">0</xforms:setvalue>

														<!-- set Numishare API -->
														<xforms:setvalue ref="instance('control-instance')/rdf-api" value="concat($series, 'apis/getRDF')"/>

														<!-- getRDF for types needs to be broken down into manageable chunks of 100 in order to not exceed the server-set URL length -->
														<xforms:action xxf:iterate="context()/id">
															<xforms:var name="uri" select="context()/@uri"/>

															<!-- set position -->
															<xforms:setvalue ref="instance('control-instance')/position"
																value="instance('control-instance')/position + 1"/>

															<!-- set proper separator based on position. IDs are to be indexed in blocks of 100 -->
															<xforms:var name="sep"
																select="if (instance('control-instance')/position = 1) then '' else if (instance('control-instance')/position mod 100 = 0) then ',' else '|'"/>

															<xforms:setvalue ref="instance('control-instance')/identifiers"
																value="concat(instance('control-instance')/identifiers, $sep, replace($uri, $series, ''))"/>
														</xforms:action>

														<!-- split the concatenated list of identifiers into blocks of 100 on the comma separator -->
														<xforms:var name="tokens" select="tokenize(instance('control-instance')/identifiers, ',')"/>

														<!-- call the /ingest pipeline with 100 IDs per API call, and post that to Solr -->
														<xforms:action xxf:iterate="$tokens">
															<xforms:setvalue ref="instance('control-instance')/identifiers" value="context()"/>
															<xforms:send submission="load-rdf"/>
														</xforms:action>
													</xforms:action>
												</xforms:action>

												<!-- after the initial URI validation, toggle interfaces, or proceed with validation -->
												<xforms:toggle case="nomisma-validation"
													if="instance('nomisma-uris')/id = false() or instance('type-symbol-uris')//id = false()"/>

												<!-- ********** DATA VALIDATION OF INDIVIDUAL ROWS ********* -->
												<xforms:action
													if="not(instance('nomisma-uris')/id = false()) and not(instance('type-symbol-uris')//id = false())">
													<!-- first delete entries, in the event of changing the mapping -->
													<xforms:delete nodeset="instance('validation-model')/record"/>

													<!-- ensure that Record IDs are unique -->
													<xforms:insert
														if="count(instance('feed')//atom:entry/*[name()=instance('mappings')/mapping[@to='id']/@from]) != count(distinct-values(instance('feed')//atom:entry/*[name()=instance('mappings')/mapping[@to='id']/@from]))"
														context="instance('validation-model')" nodeset="./child::node()[last()]"
														origin="xforms:element('error', 'Duplicate Record IDs.')"/>

													<!-- then iterate through all Atom entries -->
													<xforms:action xxf:iterate="instance('feed')//atom:entry">
														<!-- create record in the validation model -->
														<xforms:var name="title" select="atom:title"/>
														<xforms:var name="position" select="position()"/>
														<xforms:insert context="instance('validation-model')" nodeset="./child::node()[last()]"
															origin="xforms:element('record', (xforms:attribute('title', $title), ''))"/>

														<!-- iterate through all gsx elements -->
														<xforms:action
															xxf:iterate="*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended']">
															<xforms:var name="from" select="name()"/>
															<xforms:var name="value" select="normalize-space(context())"/>

															<!-- only process those fields which have been mapped in the user interface -->
															<xforms:action if="string(instance('mappings')/mapping[@from=$from]/@to)">
																<xforms:var name="mapping" select="instance('mappings')/mapping[@from=$from]/@to"/>

																<!-- ***** CONTROL ***** -->
																<!-- id -->
																<xforms:action if="$mapping = 'id'">
																	<!-- only allow certain characters as the Nomisma ID -->
																	<xforms:var name="isValid"
																		select="matches($value, &quot;^([a-zA-Z0-9\-\._\(\)&#x0027;]*)?$&quot;)"/>
																	<xforms:insert if="not(string($value)) or $isValid = false()"
																		context="instance('validation-model')/record[last()]" nodeset="./child::node()[last()]"
																		origin="xforms:element('error', 'Invalid or blank ID')"/>
																</xforms:action>

																<!-- evaluate broader, isReplacedBy, or replaces IDs to determine whether they are in this spreadsheet or load a NUDS document from exist-db -->
																<xforms:action
																	if="string-length($value) &gt; 0 and ($mapping = 'broader' or $mapping = 'isReplacedBy' or $mapping = 'replaces')">
																	<xforms:var name="isValid"
																		select="matches($value, &quot;^([a-zA-Z0-9\-\._\(\)&#x0027;]*)?$&quot;)"/>

																	<xforms:insert if="$isValid = false()" context="instance('validation-model')/record[last()]"
																		nodeset="./child::node()[last()]"
																		origin="xforms:element('error', concat('Invalid ', instance('properties')/property[. = $mapping]/@label))"/>

																	<!-- if the ID is valid, look for a corresponding record, but only if the validate-ids option is enabled -->
																	<xforms:action if="$isValid = true() and instance('control-instance')/validate-ids = true()">
																		<xforms:var name="target-id" select="$value"/>

																		<!-- if the ID hasn't already been inserted into the instance of valid parents -->
																		<xforms:action if="not(instance('parents-valid')/id = $value)">

																			<!-- if the ID is in the spreadsheet, add the ID to the 'parents-valid' instance -->
																			<xforms:action
																				if="instance('feed')//atom:entry/*[name()=instance('mappings')/mapping[@to='id']/@from][normalize-space(.) = $target-id]">
																				<xforms:insert context="instance('parents-valid')"
																				nodeset="./child::node()[last()]" origin="xforms:element('id', $target-id)"/>
																			</xforms:action>

																			<!-- if the ID is not in the spreadsheet, load a NUDS file of that ID from exist-db -->
																			<xforms:action
																				if="not(instance('feed')//atom:entry/*[name()=instance('mappings')/mapping[@to='id']/@from][normalize-space(.) = $target-id])">
																				<xforms:setvalue ref="instance('control-instance')/target-id" value="$target-id"/>
																				<xforms:setvalue ref="instance('control-instance')/mapping" value="$mapping"/>
																				<xforms:send submission="load-nuds"/>
																			</xforms:action>
																		</xforms:action>
																	</xforms:action>
																</xforms:action>

																<!-- ***** TITLES ***** -->
																<xforms:action if="$mapping = 'title'">
																	<xforms:insert if="not(string-length($value) &gt; 0)"
																		context="instance('validation-model')/record[last()]" nodeset="./child::node()[last()]"
																		origin="xforms:element('error', 'Record lacks a title')"/>
																</xforms:action>

																<!-- ***** [MOSTLY] TYPOLOGICAL METADATA ***** -->

																<!-- validate start and end dates -->
																<xforms:action if="$mapping = 'fromDate' and string-length($value) &gt; 0">
																	<xforms:insert if="not($value castable as xs:integer)"
																		context="instance('validation-model')/record[last()]" nodeset="./child::node()[last()]"
																		origin="xforms:element('error', concat('Start Date is not a number: ', $value))"/>
																	<!-- if the start date and end date are both numbers, ensure that the start date is before the end dte -->
																	<xforms:action
																		if="instance('mappings')/mapping[@to='toDate'] and $value castable as xs:integer">
																		<xforms:var name="endDate"
																			select="normalize-space(parent::node()/*[name()=instance('mappings')/mapping[@to='toDate']/@from])"/>
																		<xforms:action if="string-length($endDate) &gt; 0 and $endDate castable as xs:integer">
																			<xforms:insert if="number($value) &gt; number($endDate)"
																				context="instance('validation-model')/record[last()]"
																				nodeset="./child::node()[last()]"
																				origin="xforms:element('error', 'Start date post-dates end date')"/>
																		</xforms:action>
																	</xforms:action>
																</xforms:action>
																<xforms:action if="$mapping = 'toDate' and string-length($value) &gt; 0">
																	<xforms:insert if="not($value castable as xs:integer)"
																		context="instance('validation-model')/record[last()]" nodeset="./child::node()[last()]"
																		origin="xforms:element('error', concat('End Date is not a number: ', $value))"/>
																</xforms:action>

																<!-- URI validation -->
																<xforms:action if="ends-with($mapping, '_uri')">
																	<xforms:var name="isValid" select="starts-with($value, 'http://nomisma.org/id/')"/>
																	<xforms:insert if="string-length($value) &gt; 0 and $isValid = false()"
																		context="instance('validation-model')/record[last()]" nodeset="./child::node()[last()]"
																		origin="xforms:element('error', concat('Nomisma URI required for this field (', $mapping, '): ', $value))"> </xforms:insert>

																	<!-- evaluate whether the Object Type URI is or should be in the physical record -->
																	<xforms:action if="$mapping = 'objectType_uri'">
																		<xforms:action if="instance('config')/collection_type = 'object'">
																			<!-- the object type URI is required for a physical object when coin types are not linked -->
																			<xforms:action if="instance('control-instance')/link-to-coinType = false()">
																				<xforms:insert if="string-length($value) = 0"
																				context="instance('validation-model')/record[last()]"
																				nodeset="./child::node()[last()]"
																				origin="xforms:element('error', 'Object Type URI is required.')"/>
																			</xforms:action>
																		</xforms:action>

																		<!-- Object Type URI is always required for coin types -->
																		<xforms:action if="instance('config')/collection_type = 'cointype'">
																			<xforms:insert if="string-length($value) = 0"
																				context="instance('validation-model')/record[last()]"
																				nodeset="./child::node()[last()]"
																				origin="xforms:element('error', 'Object Type URI is required.')"/>
																		</xforms:action>
																	</xforms:action>
																</xforms:action>

																<!-- ***** REFERENCES ***** -->
																<!-- if the $mapping is a coin type URI, throw an error if the coin type URI and object type URI are blank -->
																<xforms:action
																	if="$mapping = 'coinType' and instance('control-instance')/link-to-coinType = true()">
																	<xforms:action if="string-length($value) = 0">
																		<!-- if there is an objectType URI mapping set, evaluate whether there is a value if the coin type is blank -->
																		<xforms:action
																			if="parent::node()/*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended'][name()=instance('mappings')/mapping[@to='objectType_uri']/@from]">
																			<xforms:var name="objectType_uri"
																				select="normalize-space(parent::node()/*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended'][name()=instance('mappings')/mapping[@to='objectType_uri']/@from])"/>

																			<!-- if the Object Type URI is blank and there is no Coin Type URI set -->
																			<xforms:insert if="not(string($objectType_uri))"
																				context="instance('validation-model')/record[last()]"
																				nodeset="./child::node()[last()]"
																				origin="xforms:element('error', 'No Object Type URI has been set for an object lacking a Coin Type URI')"
																			/>
																		</xforms:action>

																		<!-- if there is no objectType URI mapping, throw a different error -->
																		<xforms:action
																			if="not(parent::node()/*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended'][name()=instance('mappings')/mapping[@to='objectType_uri']/@from])">
																			<xforms:insert context="instance('validation-model')/record[last()]"
																				nodeset="./child::node()[last()]"
																				origin="xforms:element('error', 'If there is no Coin Type URI, the Object Type URI must be mapped instead')"
																			/>
																		</xforms:action>
																	</xforms:action>
																	<xforms:action if="string-length($value) &gt; 0">
																		<!-- if there is a string, validate that it is a URI and ensure it meets the nmo:TypeSeriesItem class in the RDF -->
																		<xforms:var name="isValid" select="matches($value, '^https?://')"/>

																		<xforms:action if="$isValid = true()">
																			<xforms:insert if="not(instance('rdf')/nmo:TypeSeriesItem[@rdf:about = $value])"
																				context="instance('validation-model')/record[last()]"
																				nodeset="./child::node()[last()]"
																				origin="xforms:element('error', 'The Coin Type URI does not belong to the nmo:TypeSeriesItem class, as defined in the RDF')"
																			/>
																		</xforms:action>
																		<xforms:action if="$isValid = false()">
																			<xforms:insert context="instance('validation-model')/record[last()]"
																				nodeset="./child::node()[last()]"
																				origin="xforms:element('error', 'The Coin Type is not a valid URI')"/>
																		</xforms:action>
																	</xforms:action>
																</xforms:action>

																<!-- ensure exactMatch is a URI -->
																<xforms:action if="$mapping = 'exactMatch' and string-length($value) &gt; 0">
																	<xforms:var name="isValid" select="matches($value, '^https?://')"/>

																	<xforms:insert if="$isValid = false()" context="instance('validation-model')/record[last()]"
																		nodeset="./child::node()[last()]"
																		origin="xforms:element('error', concat('Valid URI required for this field (', $mapping, '): ', $value))"
																	/>
																</xforms:action>

																<!-- validate references. Ensure that if | exists, there are only two pieces and the first one is a URI -->
																<xforms:action if="$mapping = 'reference' and string-length($value) &gt; 0">
																	<xforms:action if="contains($value, '|')">
																		<xforms:action if="count(tokenize($value, '\|')[normalize-space()]) = 2">
																			<xforms:var name="pieces" select="tokenize($value, '\|')"/>

																			<!-- if the Type Series component is a URI, ensure it is a Nomisma URI -->
																			<xforms:action if="matches($pieces[1], 'https?://')">
																				<xforms:var name="isValid"
																				select="starts-with($pieces[1], 'http://nomisma.org/id/')"/>

																				<xforms:insert if="$isValid = false()"
																				context="instance('validation-model')/record[last()]"
																				nodeset="./child::node()[last()]"
																				origin="xforms:element('error', 'The Type Series component in the reference must be a Nomisma URI')"
																				/>
																			</xforms:action>

																		</xforms:action>
																		<xforms:action if="not(count(tokenize($value, '\|')[normalize-space()]) = 2)">
																			<xforms:insert context="instance('validation-model')/record[last()]"
																				nodeset="./child::node()[last()]"
																				origin="xforms:element('error', 'A reference that contains a | character must have exactly two components')"
																			/>
																		</xforms:action>
																	</xforms:action>

																	<!-- if the value is a sole URI for a coin type, issue an error message -->
																	<xforms:action
																		if="not(contains($value, '|')) and matches($value, 'https?://') and instance('config')/collection_type = 'cointype'">
																		<xforms:insert context="instance('validation-model')/record[last()]"
																			nodeset="./child::node()[last()]"
																			origin="xforms:element('error', 'A lone URI in a reference field for a coin type collection
																			(implied coin type URI) should be designated as an Exact Match URI. Otherwise, the URI should correspond to a Type Series and be used in conjunction with a Type Number (separated by the | character).')"
																		/>
																	</xforms:action>
																</xforms:action>

																<!-- ***** PHYSICAL DESCRIPTION ***** -->

																<!-- measurements -->
																<xforms:action if="$mapping = 'axis' and string-length($value) &gt; 0">
																	<xforms:insert
																		if="not($value castable as xs:integer) or ($value castable as xs:integer and (number($value) &gt; 12 or number($value) &lt; 1))"
																		context="instance('validation-model')/record[last()]" nodeset="./child::node()[last()]"
																		origin="xforms:element('error', 'The axis must be an integer between 1 and 12')"/>
																</xforms:action>

																<xforms:action
																	if="string-length($value) &gt; 0 and 
																	($mapping = 'weight' or $mapping = 'height' or $mapping = 'width' or $mapping = 'diameter' or $mapping = 'thickness')">
																	<!-- insert an error if the $value is not a decimal number -->
																	<xforms:insert
																		if="not($value castable as xs:decimal) or ($value castable as xs:decimal and number($value) &lt;= 0)"
																		context="instance('validation-model')/record[last()]" nodeset="./child::node()[last()]"
																		origin="xforms:element('error', concat('The ', $mapping, ' must be a decimal number greater than 0'))"
																	/>
																</xforms:action>
															</xforms:action>
														</xforms:action>
														<!-- end of iteration -->
													</xforms:action>

													<!-- after validation, change the import-trigger button value, if necessary, and switch the case -->
													<xforms:setvalue ref="instance('control-instance')/import-trigger" value="true()"
														if="count(instance('validation-model')//error) = 0"/>
													<xforms:toggle case="validation-interface"/>
												</xforms:action>

												<!-- end of xforms-submit-done -->
											</xforms:action>
											<!-- end of DOMActivate -->
										</xforms:action>
									</xforms:trigger>
								</xforms:group>
							</div>
						</xforms:case>
						<xforms:case id="mapping-error-interface">
							<div>
								<h3>Mapping Error</h3>
								<p>The Atom representation of the Google Spreadsheet has successfully loaded, but it does not appear to contain content.</p>
							</div>
						</xforms:case>
						<xforms:case id="validation-interface">
							<xforms:group ref="instance('validation-model')">
								<div>
									<h3>Validation</h3>
									<xforms:group ref=".[count(descendant::error) = 0]">
										<div class="alert-success alert-box alert">
											<span class="glyphicon glyphicon-ok"></span>
											<strong>Success: </strong><xforms:output value="count(record)"/> records successfully validated.</div>
									</xforms:group>
									<xforms:group ref=".[count(descendant::error) &gt; 0]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> The spreadsheet is invalid. Please fix errors and import again.</div>
									</xforms:group>
									<!-- if the error is on the top level -->
									<xforms:group ref=".[error]">
										<div class="alert-danger alert-box alert">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong>
											<xforms:output ref="error"/>
										</div>
									</xforms:group>
									<!-- if there are errors or warnings, then display the table -->
									<xforms:group ref=".[count(record[warning]) &gt; 0  or count(record[error]) &gt; 0]">
										<p><b><xforms:output value="count(record[error])"/></b> of <b><xforms:output value="count(record)"/></b> total records
											contain errors. <b><xforms:output value="count(record[warning])"/></b> contain warnings. See below.</p>
										<table class="table">
											<thead>
												<th width="25%">ID</th>
												<th>Messages</th>
											</thead>
											<tbody>
												<xforms:repeat nodeset="record[warning or error]">
													<tr>
														<td><xforms:output ref="@title"/></td>
														<td>
															<xforms:repeat nodeset="error">
																<div>
																	<xforms:output ref=".">
																		<xforms:label>Error</xforms:label>
																	</xforms:output>
																</div>
															</xforms:repeat>
															<xforms:repeat nodeset="warning">
																<div>
																	<xforms:output ref=".">
																		<xforms:label>Warning</xforms:label>
																	</xforms:output>
																</div>
															</xforms:repeat>
														</td>
													</tr>
												</xforms:repeat>
											</tbody>
										</table>
									</xforms:group>
									<!-- if there are no errors, then allow the validation button -->
									<xforms:trigger bind="import-trigger">
										<xforms:label>Import Data</xforms:label>
										<xforms:action ev:event="DOMActivate">
											<!-- set the current dateTime into a variable that will apply to all IDs 
											(previous version resulting in different time for each ID in spreadsheet -->
											<xforms:var name="dateTime" select="current-dateTime()"/>

											<!-- reset position and identifiers, which were previously used for getRDF API calls -->
											<xforms:setvalue ref="instance('control-instance')/identifiers"/>
											<xforms:setvalue ref="instance('control-instance')/position">0</xforms:setvalue>

											<!-- begin processing the spreadsheet into RDF -->
											<xforms:action xxf:iterate="instance('feed')//atom:entry">
												<xforms:var name="id"
													select="normalize-space(data(context()/*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended'][name()=instance('mappings')/mapping[@to='id']/@from]))"/>
												<xforms:var name="position" select="position()"/>

												<xforms:setvalue ref="instance('control-instance')/id" value="$id"/>

												<!-- clear data from NUDS instance before loading-->
												<xforms:delete nodeset="instance('nuds')/*"/>
												<xforms:insert context="instance('nuds')" origin="instance('control-template')"/>
												<xforms:insert context="instance('nuds')" nodeset="./child::node()[last()]"
													origin="instance('descMeta-template')"/>

												<!-- *** set control metadata *** -->
												<!-- set publicationStatus and maintenanceStatus based on isReplacedBy or broader value -->
												<xforms:setvalue ref="instance('nuds')/nuds:control/nuds:publicationStatus"
													value="if (instance('control-instance')/deprecate-ids = true())
															then 'deprecatedType'
														else if (count(context()/*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended'][name()=instance('mappings')/mapping[@to='isReplacedBy']/@from][normalize-space()]) &gt;= 1) 
															then 'deprecatedType'															
														else if (count(context()/*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended'][name()=instance('mappings')/mapping[@to='broader']/@from][normalize-space()]) &gt;= 1)
															then 'approvedSubtype'														
														else 'approved'"/>
												<!-- if there's more than one isReplacedBy, then the status is cancelledSplit -->
												<xforms:setvalue ref="instance('nuds')/nuds:control/nuds:maintenanceStatus"
													value="if (count(context()/*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended'][name()=instance('mappings')/mapping[@to='isReplacedBy']/@from][normalize-space()]) &gt; 1)
															then 'cancelledSplit'
														else if (count(context()/*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended'][name()=instance('mappings')/mapping[@to='isReplacedBy']/@from][normalize-space()]) = 1) 
															then 'cancelledReplaced'
														else if (instance('control-instance')/deprecate-ids = true())
															then 'cancelled'
														else 'derived'"/>

												<!-- set maintenanceAgency -->
												<xforms:setvalue ref="instance('nuds')/nuds:control/nuds:maintenanceAgency/nuds:agencyName"
													value="instance('config')/template/agencyName"/>

												<!-- record provenance -->
												<xforms:setvalue ref="instance('nuds')/nuds:control/nuds:maintenanceHistory/nuds:maintenanceEvent/nuds:agent"
													value="instance('control-instance')/username"/>
												<xforms:setvalue
													ref="instance('nuds')/nuds:control/nuds:maintenanceHistory/nuds:maintenanceEvent/nuds:eventDateTime/@standardDateTime"
													value="$dateTime"/>
												<xforms:setvalue
													ref="instance('nuds')/nuds:control/nuds:maintenanceHistory/nuds:maintenanceEvent/nuds:eventDateTime"
													value="format-dateTime($dateTime, '[D] [MNn] [Y0001], [H01]:[m01]:[s01]')"/>
												<xforms:setvalue ref="instance('nuds')/nuds:control/nuds:maintenanceHistory/nuds:maintenanceEvent/nuds:source"
													value="instance('control-instance')/spreadsheet-uri"/>

												<!-- if there is a coin type URI -->
												<xforms:var name="coinType_uri"
													select="normalize-space(data(context()/*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended'][name()=instance('mappings')/mapping[@to='coinType']/@from][normalize-space()]))"/>

												<!-- *** BEGIN ATOM TO RDF IMPORT *** -->
												<xforms:action
													xxf:iterate="context()/*[namespace-uri()='http://schemas.google.com/spreadsheets/2006/extended']">
													<xforms:var name="from" select="name()"/>
													<xforms:var name="value" select="normalize-space(data(context()))"/>

													<!-- only process those fields which have been mapped in the user interface -->
													<xforms:action if="string(instance('mappings')/mapping[@from=$from]/@to) and string-length($value) &gt; 0">
														<xforms:var name="mapping" select="instance('mappings')/mapping[@from=$from]/@to"/>

														<!-- recordId -->
														<xforms:action if="$mapping = 'id'">
															<xforms:setvalue ref="instance('nuds')/nuds:control/nuds:recordId" value="$value"/>
														</xforms:action>

														<!-- otherRecordIds -->
														<xforms:action
															if="$mapping = 'broader' or $mapping = 'replaces' or $mapping = 'isReplacedBy' or $mapping = 'exactMatch' or $mapping = 'typeNumber' or $mapping = 'sortId'">
															<xforms:var name="property"
																select="if (contains($mapping, 'place')) then concat('dcterms:', $mapping) else concat('skos:', $mapping)"/>

															<xforms:insert context="instance('nuds')/nuds:control"
																nodeset="if (nuds:otherRecordId) then nuds:otherRecordId else nuds:recordId" position="after"
																origin="instance('otherRecordId-template')"/>

															<!-- insert semantic when there is an RDF property -->
															<xforms:insert if="not($mapping = 'typeNumber') and not($mapping = 'sortId')"
																context="instance('nuds')/nuds:control/nuds:otherRecordId[last()]"
																origin="xforms:attribute(resolve-QName('semantic', self::node()), $property)"/>
															<!-- typeNumber is a @localType -->
															<xforms:insert if="$mapping = 'typeNumber' or $mapping = 'sortId'"
																context="instance('nuds')/nuds:control/nuds:otherRecordId[last()]"
																origin="xforms:attribute(resolve-QName('localType', self::node()), $mapping)"/>

															<xforms:setvalue ref="instance('nuds')/nuds:control/nuds:otherRecordId[last()]" value="$value"/>

															<!-- if the exactMatch-to-reference box is checked, then create a reference and link to it -->
															<xforms:action
																if="$mapping = 'exactMatch' and instance('control-instance')/exactMatch-reference = true()">
																<!-- insert refDesc if one does not exist -->
																<xforms:insert context="instance('nuds')/nuds:descMeta" nodeset="./child::node()[last()]"
																	origin="instance('refDesc-template')" if="not(instance('nuds')/nuds:descMeta/nuds:refDesc)"/>

																<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:refDesc"
																	nodeset="./child::node()[last()]" origin="instance('reference-template')"/>
																<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]"
																	origin="xforms:attribute(resolve-QName('xlink:href', self::node()), $value)"/>
																<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]"
																	origin="xforms:attribute(resolve-QName('xlink:type', self::node()), 'simple')"/>
																<xforms:setvalue ref="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]"
																	value="instance('rdf')/*[@rdf:about=$value]/skos:prefLabel[@xml:lang='en']"/>
															</xforms:action>
														</xforms:action>

														<!-- ***** DESCMETA ***** -->

														<!-- titles -->
														<xforms:action if="$mapping = 'title'">
															<xforms:var name="lang" select="instance('mappings')/mapping[@from=$from]/@lang"/>

															<xforms:setvalue ref="instance('title-template')" value="$value"/>
															<xforms:setvalue ref="instance('title-template')/@xml:lang" value="$lang"/>

															<xforms:insert context="instance('nuds')/nuds:descMeta" origin="instance('title-template')"/>
														</xforms:action>

														<!-- ** NOTES ** -->
														<xforms:action if="$mapping = 'note' and string-length($value) &gt; 0">
															<xforms:var name="lang" select="instance('mappings')/mapping[@from=$from]/@lang"/>
															<xforms:var name="property" select="instance('mappings')/mapping[@from=$from]/@property"/>

															<xforms:insert context="instance('nuds')/nuds:descMeta" nodeset="nuds:title[last()]"
																origin="instance('noteSet-template')" if="not(instance('nuds')/nuds:descMeta/nuds:noteSet)"/>

															<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:noteSet"
																nodeset="./child::node()[last()]" origin="instance('note-template')"/>
															<xforms:setvalue ref="instance('nuds')/nuds:descMeta/nuds:noteSet/nuds:note[last()]" value="$value"/>
															<xforms:setvalue ref="instance('nuds')/nuds:descMeta/nuds:noteSet/nuds:note[last()]/@xml:lang"
																value="$lang"/>

															<!-- insert semantic property into a semantic element, if set -->
															<xforms:insert if="string($property)"
																context="instance('nuds')/nuds:descMeta/nuds:noteSet/nuds:note[last()]"
																origin="xforms:attribute(resolve-QName('semantic', self::node()), $property)"/>
														</xforms:action>

														<!-- ***** TYPEDESC ***** -->
														<!-- if there is a coinType URI in the Atom entry and the control to insert a URI into the typeDesc is enabled, inset XLink attributes -->
														<xforms:action if="string($coinType_uri) and instance('control-instance')/link-to-coinType = true()">
															<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc"
																origin="xforms:attribute(resolve-QName('xlink:href', self::node()), $coinType_uri)"/>
															<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc"
																origin="xforms:attribute(resolve-QName('xlink:type', self::node()), 'simple')"/>
														</xforms:action>

														<!-- otherwise process all possible typeDesc mappings and insert elements into the typeDesc -->
														<xforms:action
															if="not(string($coinType_uri)) or instance('control-instance')/link-to-coinType = false()">
															<!-- ** PARSE URIs ** -->
															<xforms:action if="ends-with($mapping, '_uri')">
																<xforms:var name="uri"
																	select="if (ends-with($value, '?')) then substring-before($value, '?') else $value"/>
																<xforms:var name="uncertain" select="if (ends-with($value, '?')) then true() else false()"/>

																<!-- get the preferred label from the Nomisma RDF -->
																<xforms:var name="label"
																	select="if (instance('rdf')/*[@rdf:about=$uri]/skos:prefLabel[@xml:lang=instance('control-instance')/language]) 
																then instance('rdf')/*[@rdf:about=$uri]/skos:prefLabel[@xml:lang=instance('control-instance')/language] 
																else instance('rdf')/*[@rdf:about=$uri]/skos:prefLabel[@xml:lang='en']"/>

																<!-- evaluate the placement of the element into the appropriate context -->
																<xforms:action if="starts-with($mapping, 'geo_')">
																	<xforms:var name="role" select="substring-after(substring-before($mapping, '_uri'), 'geo_')"/>

																	<!-- insert geographic if it doesn't exist -->
																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc"
																		nodeset="./*[name() &lt;= $mapping]" origin="instance('geographic-template')"
																		if="not(instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:geographic)"/>

																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:geographic"
																		nodeset="./child::node()[last()]" origin="instance('geogname-template')"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:geographic/nuds:geogname[last()]"
																		value="$label"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:geographic/nuds:geogname[last()]/@xlink:href"
																		value="$uri"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:geographic/nuds:geogname[last()]/@xlink:role"
																		value="$role"/>
																	<xforms:insert
																		context="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:geographic/nuds:geogname[last()]"
																		origin="xforms:attribute(resolve-QName('certainty', self::node()), 'http://nomisma.org/id/uncertain_value')"
																		if="$uncertain = true()"/>
																</xforms:action>
																<xforms:action if="starts-with($mapping, 'auth_')">
																	<xforms:var name="element"
																		select="if (instance('rdf')/*[@rdf:about=$uri]/name()='foaf:Person') then 'persname' else if (instance('rdf')/*[@rdf:about=$uri]/name()='rdac:Family') then 'famname' else 'corpname'"/>
																	<xforms:var name="role"
																		select="substring-after(substring-before($mapping, '_uri'), 'auth_')"/>

																	<!-- insert authority if it doesn't exist -->
																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc"
																		nodeset="./*[name() &lt;= $mapping]" origin="instance('authority-template')"
																		if="not(instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:authority)"/>

																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:authority"
																		nodeset="./child::node()[last()]" origin="instance(concat($element, '-template'))"/>
																	<xforms:setvalue ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:authority/*[last()]"
																		value="$label"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:authority/*[last()]/@xlink:href"
																		value="$uri"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:authority/*[last()]/@xlink:role"
																		value="$role"/>
																	<xforms:insert
																		context="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:authority/*[last()]"
																		origin="xforms:attribute(resolve-QName('certainty', self::node()), 'http://nomisma.org/id/uncertain_value')"
																		if="$uncertain = true()"/>
																</xforms:action>
																<xforms:action if="starts-with($mapping, 'obv_') or starts-with($mapping, 'rev_')">
																	<xforms:var name="container"
																		select="if (starts-with($mapping, 'obv_')) then 'obverse' else 'reverse'"/>
																	<xforms:var name="role" select="substring-after(substring-before($mapping, '_uri'), 'v_')"/>

																	<!-- insert obverse/reverse container element -->
																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc"
																		nodeset="./*[name() &lt;= $mapping]" origin="instance(concat($container, '-template'))"
																		if="not(instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container])"/>

																	<xforms:insert
																		context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]"
																		nodeset="./child::node()[last()]" origin="instance('persname-template')"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:persname[last()]"
																		value="$label"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:persname[last()]/@xlink:href"
																		value="$uri"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:persname[last()]/@xlink:role"
																		value="$role"/>
																	<xforms:insert
																		context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/*[last()]"
																		origin="xforms:attribute(resolve-QName('certainty', self::node()), 'http://nomisma.org/id/uncertain_value')"
																		if="$uncertain = true()"/>
																</xforms:action>
																<xforms:action
																	if="not(starts-with($mapping, 'geo_')) and not(starts-with($mapping, 'auth_')) and not(starts-with($mapping, 'obv_')) and not(starts-with($mapping, 'rev_'))">
																	<xforms:var name="element" select="substring-before($mapping, '_uri')"/>

																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc"
																		nodeset="./*[name() &lt;= $mapping]" origin="instance(concat($element, '-template'))"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$element][last()]"
																		value="$label"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$element][last()]/@xlink:href"
																		value="$uri"/>
																	<xforms:insert
																		context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$element][last()]"
																		origin="xforms:attribute(resolve-QName('certainty', self::node()), 'http://nomisma.org/id/uncertain_value')"
																		if="$uncertain = true()"/>
																</xforms:action>
															</xforms:action>

															<!-- ** OBVERSE/REVERSE ** -->
															<xforms:action
																if="(starts-with($mapping, 'obv_') or starts-with($mapping, 'rev_')) and not(ends-with($mapping, '_uri'))">
																<xforms:var name="container"
																	select="if (starts-with($mapping, 'obv_')) then 'obverse' else 'reverse'"/>
																<xforms:var name="element"
																	select="if (starts-with($mapping, 'obv_')) then substring-after($mapping, 'obv_') else substring-after($mapping, 'rev_')"/>

																<!-- insert obverse/reverse container element -->
																<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc"
																	nodeset="./*[name() &lt;= $mapping]" origin="instance(concat($container, '-template'))"
																	if="not(instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container])"/>

																<!-- insert type element once and multiple description elements -->
																<xforms:action if="$element = 'type'">
																	<xforms:var name="lang" select="instance('mappings')/mapping[@from=$from]/@lang"/>

																	<xforms:insert
																		context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]"
																		nodeset="./*[name() &lt;= $element]" origin="instance('type-template')"
																		if="not(instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:type)"/>
																	<xforms:insert
																		context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:type"
																		nodeset="./child::node()[last()]" origin="instance('description-template')"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:type/nuds:description[last()]"
																		value="$value"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:type/nuds:description[last()]/@xml:lang"
																		value="$lang"/>
																</xforms:action>

																<xforms:action if="$element = 'legend' or $element = 'die'">
																	<xforms:insert
																		context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]"
																		nodeset="./*[name() &lt;= $element]" origin="instance(concat($element, '-template'))"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/*[local-name()=$element][last()]"
																		value="$value"/>
																</xforms:action>

																<xforms:action if="ends-with($element, 'symbol')">

																	<xforms:var name="symbol_position"
																		select="if (contains($element, '_')) then substring-before($element, '_symbol') else ''"/>

																	<!-- evaluate whether the $value is a URI or not -->
																	<xforms:action if="matches($value, '^https?://')">
																		<xforms:var name="uri"
																			select="if (ends-with($value, '?')) then substring-before($value, '?') else $value"/>
																		<xforms:var name="uncertain"
																			select="if (ends-with($value, '?')) then true() else false()"/>
																		<!-- get preferred label from RDF -->
																		<xforms:var name="label"
																			select="if (instance('rdf')/*[@rdf:about=$uri]/skos:prefLabel[@xml:lang=instance('control-instance')/language]) 
																		then instance('rdf')/*[@rdf:about=$uri]/skos:prefLabel[@xml:lang=instance('control-instance')/language] 
																		else instance('rdf')/*[@rdf:about=$uri]/skos:prefLabel[@xml:lang='en']"/>
																		<xforms:insert
																			context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]"
																			nodeset="./*[name() &lt;= 'symbol']" origin="instance('symbol-template')"/>

																		<!-- insert attributes -->
																		<xforms:insert if="string($symbol_position)"
																			context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:symbol[last()]"
																			origin="xforms:attribute(resolve-QName('position', self::node()), $symbol_position)"/>
																		<xforms:insert
																			context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:symbol[last()]"
																			origin="xforms:attribute(resolve-QName('xlink:href', self::node()), $uri)"/>
																		<xforms:insert
																			context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:symbol[last()]"
																			origin="xforms:attribute(resolve-QName('xlink:type', self::node()), 'simple')"/>
																		<xforms:setvalue
																			ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:symbol[last()]"
																			value="$label"/>

																		<!-- insert arcrole for nmo:hasControlmark if the RDF class of the URI is nmo:Monogram -->
																		<xforms:insert if="instance('rdf')/nmo:Monogram[@rdf:about = $uri]"
																			context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:symbol[last()]"
																			origin="xforms:attribute(resolve-QName('xlink:arcrole', self::node()), 'nmo:hasControlmark')"/>

																		<!-- insert uncertainty if true() -->
																		<xforms:insert
																			context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:symbol[last()]"
																			origin="xforms:attribute(resolve-QName('certainty', self::node()), 'http://nomisma.org/id/uncertain_value')"
																			if="$uncertain = true()"/>
																	</xforms:action>
																	<xforms:action if="not(matches($value, '^https?://'))">
																		
																		<!--<xforms:message level="modal"><xforms:output value="$value"/></xforms:message>-->
																		
																		<xforms:insert
																			context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]"
																			nodeset="./*[name() &lt;= 'symbol']" origin="instance('symbol-template')"/>
																		<xforms:setvalue
																			ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:symbol[last()]"
																			value="$value"/>

																		<!-- insert position, if set -->
																		<xforms:insert if="string($symbol_position)"
																			context="instance('nuds')/nuds:descMeta/nuds:typeDesc/*[local-name()=$container]/nuds:symbol[last()]"
																			origin="xforms:attribute(resolve-QName('position', self::node()), $symbol_position)"
																		/>
																	</xforms:action>
																</xforms:action>
															</xforms:action>

															<!-- ** DATE/DATERANGE ** -->
															<xforms:action if="$mapping = 'fromDate'">
																<xforms:var name="year" select="number($value)"/>
																<xforms:var name="toDate"
																	select="normalize-space(parent::node()/*[name()=instance('mappings')/mapping[@to='toDate']/@from])"/>

																<!-- if $toDate is an integer, and it is not the same as $value, then create dateRange -->
																<xforms:action if="$toDate castable as xs:integer and not($value = $toDate)">
																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc"
																		nodeset="./*[name() &lt;= $mapping]" origin="instance('dateRange-template')"/>

																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:dateRange/nuds:fromDate/@standardDate"
																		value="format-number($year, '0000')"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:dateRange/nuds:fromDate"
																		value="if ($year &lt; 0) then concat(abs($year), ' BCE') else $year"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:dateRange/nuds:toDate/@standardDate"
																		value="format-number(number($toDate), '0000')"/>
																	<xforms:setvalue
																		ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:dateRange/nuds:toDate"
																		value="if (number($toDate) &lt; 0) then concat(abs(number($toDate)), ' BCE') else $toDate"
																	/>
																</xforms:action>
																<xforms:action if="not($toDate castable as xs:integer) or $value = $toDate">
																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc"
																		nodeset="./*[name() &lt;= $mapping]" origin="instance('date-template')"/>

																	<!-- set date values -->
																	<xforms:setvalue ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:date/@standardDate"
																		value="format-number($year, '0000')"/>
																	<xforms:setvalue ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:date"
																		value="if ($year &lt; 0) then concat(abs($year), ' BCE') else $year"/>
																</xforms:action>
															</xforms:action>
															<xforms:action if="$mapping = 'toDate'">
																<xforms:var name="year" select="number($value)"/>

																<xforms:var name="fromDate"
																	select="normalize-space(parent::node()/*[name()=instance('mappings')/mapping[@to='fromDate']/@from])"/>

																<!-- insert nuds:date if there is no $fromDate -->
																<xforms:action if="not($fromDate castable as xs:integer)">
																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:typeDesc"
																		nodeset="./*[name() &lt;= $mapping]" origin="instance('date-template')"/>

																	<!-- set date values -->
																	<xforms:setvalue ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:date/@standardDate"
																		value="format-number($year, '0000')"/>
																	<xforms:setvalue ref="instance('nuds')/nuds:descMeta/nuds:typeDesc/nuds:date"
																		value="if ($year &lt; 0) then concat(abs($value), ' BCE') else $value"/>
																</xforms:action>
															</xforms:action>
														</xforms:action>

														<!-- ***** PHYSDESC ***** -->
														<xforms:action if="$mapping = 'axis'">
															<!-- insert physDesc if it doesn't exist -->
															<xforms:insert if="not(instance('nuds')/nuds:descMeta/nuds:physDesc)"
																context="instance('nuds')/nuds:descMeta" nodeset="./*[contains(name(), 'Desc')]/preceding::*[1]"
																origin="instance('physDesc-template')"/>

															<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:physDesc"
																nodeset="./*[name() &lt;= $mapping]" origin="instance('axis-template')"/>
															<xforms:setvalue ref="instance('nuds')/nuds:descMeta/nuds:physDesc/nuds:axis" value="$value"/>
														</xforms:action>

														<xforms:action
															if="$mapping = 'weight' or $mapping = 'height' or $mapping = 'width' or $mapping = 'diameter' or $mapping = 'thickness'">
															<!-- insert physDesc if it doesn't exist -->
															<xforms:insert if="not(instance('nuds')/nuds:descMeta/nuds:physDesc)"
																context="instance('nuds')/nuds:descMeta" nodeset="./*[contains(name(), 'Desc')]/preceding::*[1]"
																origin="instance('physDesc-template')"/>
															<!-- insert measurementsSet -->
															<xforms:insert if="not(instance('nuds')/nuds:descMeta/nuds:physDesc/nuds:measurementsSet)"
																context="instance('nuds')/nuds:descMeta/nuds:physDesc"
																nodeset="./*[name() &lt;= 'measurementsSet']" origin="instance('measurementsSet-template')"/>

															<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:physDesc/nuds:measurementsSet"
																nodeset="./*[name() &lt;= $mapping]" origin="instance(concat($mapping, '-template'))"/>
															<xforms:setvalue
																ref="instance('nuds')/nuds:descMeta/nuds:physDesc/nuds:measurementsSet/*[local-name()=$mapping]"
																value="$value"/>
														</xforms:action>

														<!-- ***** REFDESC ***** -->
														<xforms:action if="$mapping = 'reference'">
															<!-- insert refDesc if one does not exist -->
															<xforms:insert context="instance('nuds')/nuds:descMeta" nodeset="./child::node()[last()]"
																origin="instance('refDesc-template')" if="not(instance('nuds')/nuds:descMeta/nuds:refDesc)"/>

															<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:refDesc"
																nodeset="./child::node()[last()]" origin="instance('reference-template')"/>

															<!-- if there is a | character, then split into title and idno in TEI -->
															<xforms:action if="contains($value, '|')">
																<xforms:var name="pieces" select="tokenize($value, '\|')"/>

																<!-- evaluate whether the bibliographic portion is a URI or literal -->
																<xforms:action if="matches($pieces[1], '^https?://')">
																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]"
																		origin="xforms:element(resolve-QName('tei:title', self::node()), (xforms:attribute('key', $pieces[1]), data(instance('rdf')/*[@rdf:about=$pieces[1]]/skos:prefLabel[@xml:lang='en'])))"
																	/>
																</xforms:action>
																<xforms:action if="not(matches($pieces[1], '^https?://'))">
																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]"
																		origin="xforms:element(resolve-QName('tei:title', self::node()), $pieces[1])"/>
																</xforms:action>

																<!-- insert the TEI identifier -->
																<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]"
																	nodeset="./child::node()[last()]"
																	origin="xforms:element(resolve-QName('tei:idno', self::node()), $pieces[2])"/>
															</xforms:action>

															<!-- otherwise evaluate literal or URI -->
															<xforms:action if="not(contains($value, '|'))">
																<xforms:action if="matches($value, '^https?://')">
																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]"
																		origin="xforms:attribute(resolve-QName('xlink:type', self::node()), 'simple')"/>
																	<xforms:insert context="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]"
																		origin="xforms:attribute(resolve-QName('xlink:href', self::node()), $value)"/>

																	<!-- set label: use preferred label if the URI is a nmo:TypeSeriesItem, otherwise use the URI -->
																	<xforms:setvalue if="instance('rdf')/nmo:TypeSeriesItem[@rdf:about = $value]"
																		ref="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]"
																		value="instance('rdf')/nmo:TypeSeriesItem[@rdf:about=$value]/skos:prefLabel[@xml:lang='en']"/>
																	<xforms:setvalue if="not(instance('rdf')/nmo:TypeSeriesItem[@rdf:about = $value])"
																		ref="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]" value="$value"/>

																	<!-- insert an arcrole if the URI is an nmo:TypeSeriesItem -->
																	<xforms:insert if="instance('rdf')/nmo:TypeSeriesItem[@rdf:about = $value]"
																		context="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]"
																		origin="xforms:attribute(resolve-QName('xlink:arcrole', self::node()), 'nmo:hasTypeSeriesItem')"
																	/>
																</xforms:action>
																<xforms:action if="not(matches($value, '^https?://'))">
																	<xforms:setvalue ref="instance('nuds')/nuds:descMeta/nuds:refDesc/nuds:reference[last()]"
																		value="$value"/>
																</xforms:action>
															</xforms:action>
														</xforms:action>

														<!-- ***** ADMINDESC ***** -->
													</xforms:action>
												</xforms:action>

												<!-- *** BEGIN CRUD OPERATIONS *** -->
												<!-- save NUDS/XML to eXist-db collection -->
												<xforms:send submission="save-nuds"/>
											</xforms:action>

											<!-- *** after each row in the spreadsheet has been processed execute following processes *** -->

											<!-- if the types should be indexed into Solr, publish all non-deprecated IDs -->
											<xforms:action if="instance('control-instance')/index-to-solr = true()">

												<!-- split the concatenated list of identifiers into blocks of 100 on the comma separator -->
												<xforms:var name="tokens" select="tokenize(instance('control-instance')/identifiers, ',')"/>

												<!-- call the /ingest pipeline with 100 IDs per API call, and post that to Solr -->
												<xforms:action xxf:iterate="$tokens">
													<xforms:setvalue ref="instance('control-instance')/identifiers" value="context()"/>
													<!-- get Solr document -->
													<xforms:send submission="generate-add-document"/>
													<!-- on xforms-submit-done, the document is posted and a commit posted -->
												</xforms:action>
											</xforms:action>

											<xforms:toggle case="process-complete"/>
										</xforms:action>
									</xforms:trigger>
								</div>
							</xforms:group>
						</xforms:case>
						<xforms:case id="process-complete">
							<p>The process has been completed successfully. Click the link above to return to the Admin panel.</p>
						</xforms:case>
					</xforms:switch>
					<!--<fr:xforms-inspector/>-->
				</div>
			</div>
		</div>
	</body>
</html>
